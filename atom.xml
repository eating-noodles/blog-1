<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷石</title>
  <icon>https://coldstone.fun/avatar.png</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coldstone.fun/"/>
  <updated>2020-06-18T09:46:58.876Z</updated>
  <id>https://coldstone.fun/</id>
  
  <author>
    <name>ColdStone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最好的你</title>
    <link href="https://coldstone.fun/post/2020/06/17/leetcode-1014/"/>
    <id>https://coldstone.fun/post/2020/06/17/leetcode-1014/</id>
    <published>2020-06-17T06:19:00.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">LeetCode 1014. 最佳观光组合</a></p><img src="./images/best_of_you.png" width="1106" style="width:553px" alt="best_of_you">]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-sightseeing-pair/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 1014.
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="代码写诗" scheme="https://coldstone.fun/tags/%E4%BB%A3%E7%A0%81%E5%86%99%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>使用 Flutter 绘制图表（二）饼状图🍪</title>
    <link href="https://coldstone.fun/post/2020/06/09/flutter-pie-chart/"/>
    <id>https://coldstone.fun/post/2020/06/09/flutter-pie-chart/</id>
    <published>2020-06-09T06:08:00.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/flutter-pie-chart/cover.png" alt="pie"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接上文，本文讲解如何使用 Flutter 绘制饼状图，最终效果如图</p><img src="./images/flutter-pie-chart/pie.gif" width="524" style="width:260px"><p><a href="https://dartpad.dartlang.org/b8a2b88647fa75df5d31445a93cb390f" target="_blank" rel="noopener">在线查看</a></p><h2 id="定义-PieChart-amp-PiePart"><a href="#定义-PieChart-amp-PiePart" class="headerlink" title="定义 PieChart &amp; PiePart"></a>定义 PieChart &amp; PiePart</h2><p>第一步定义 <code>PieChart</code> 和 <code>PiePart</code> 类。<code>PieChart</code> 是整个饼状图控件，有 <code>datas</code> 和 <code>legends</code> 两个属性，表示饼图的数据和每部分的标识。<br><code>PiePart</code> 表示饼图的一部分，有 <code>color</code>, <code>startAngle</code>, <code>sweepAngle</code> 三个属性，分别表示颜色，起始弧度值，占据圆形的弧度值。<code>PeiChartPainter</code> 类实现了具体的绘制方法。</p><pre><code class="dart">class PiePart {  double sweepAngle;  final Color color;  final double startAngle;  PiePart(    this.startAngle,    this.sweepAngle,    this.color,  );}class PieChart extends StatefulWidget {  final List&lt;double&gt; datas;  final List&lt;String&gt; legends;  const PieChart({    @required this.datas,    @required this.legends,  });  @override  _PieChartState createState() =&gt; _PieChartState();}class _PieChartState extends State&lt;PieChart&gt; with TickerProviderStateMixin {  double _total = 0.0;  final List&lt;PiePart&gt; _parts = &lt;PiePart&gt;[];  @override  Widget build(BuildContext context) {    return Column(      mainAxisAlignment: MainAxisAlignment.center,      children: [        Container(          width: 300,          height: 300,          child: CustomPaint(            painter: PeiChartPainter(              total: _total,              parts: _parts,              datas: widget.datas,              legends: widget.legends            ),          ),        ),      ],    );  }}class PeiChartPainter extends CustomPainter {  final double total;  final List&lt;double&gt; datas;  final List&lt;PiePart&gt; parts;  final List&lt;String&gt; legends;  PeiChartPainter({    @required this.total,    @required this.datas,    @required this.parts,    @required this.legends,  });  @override  void paint(Canvas canvas, Size size) {    // TODO  }  @override  bool shouldRepaint(PeiChartPainter oldDelegate) =&gt; true;}</code></pre><h2 id="绘制圆框"><a href="#绘制圆框" class="headerlink" title="绘制圆框"></a>绘制圆框</h2><p>先绘制图表的圆框，在 <code>PeiChartPainter</code> 上添加 <code>drawCircle</code> 方法，以圆的中心点和圆的半径绘制一个空心圆形。</p><pre><code class="dart">void drawCircle(Canvas canvas, Size size) {  final sw = size.width;  final sh = size.height;  // 确定圆的半径  final double radius = math.min(sw, sh) / 2;  // 定义中心点  final Offset center = Offset(sw / 2, sh / 2);  // 定义圆形的绘制属性  final paint = Paint()    ..style = PaintingStyle.stroke    ..color = Colors.grey    ..strokeWidth = 1.0;  // 使用 Canvas 的 drawCircle 绘制  canvas.drawCircle(center, radius, paint);}@overridevoid paint(Canvas canvas, Size size) {  drawCircle(canvas, size);}</code></pre><img src="./images/flutter-pie-chart/circle.png" width="520" style="width:260px"><h2 id="绘制标识"><a href="#绘制标识" class="headerlink" title="绘制标识"></a>绘制标识</h2><p>这一步需要先在 <code>_PieChartState</code> 里面进行数据的初始化，然后绘制每个数据对应的标识，分以下几步进行</p><ol><li>计算出每个数据占总和的占比</li><li>根据占比计算数据占据圆的弧度值</li><li>根据之前数据占据圆形的弧度值计算出下一个数据的起始弧度值</li><li>根据计算出的起始弧度值和占据弧度值创建 <code>PiePart</code> 对象</li><li>使用 <code>PiePart</code> 对象绘制标识</li></ol><pre><code class="dart">class _PieChartState extends State&lt;PieChart&gt; with TickerProviderStateMixin {  double _total = 0.0;  final List&lt;PiePart&gt; _parts = &lt;PiePart&gt;[];  @override  void initState() {    super.initState();    List&lt;double&gt; datas = widget.datas;    // 计算出数据总和    _total = datas.reduce((a, b) =&gt; a + b);    // 定义一个起始变量    double startAngle = 0.0;    for (int i = 0; i &lt; datas.length; i++) {      final data = datas[i];      // 计算出每个数据所占的弧度值      final angle = (data / _total) * -math.pi * 2;      PiePart peiPart;      if (i &gt; 0) {        // 下一个数据的起始弧度值等于之前的数据弧度值之和        double lastSweepAngle = _parts[i - 1].sweepAngle;        startAngle += lastSweepAngle;        peiPart = PiePart(startAngle, angle, colors[i]);      } else {        // 第一个数据的起始弧度为 0.0        peiPart = PiePart(0.0, angle, colors[i]);      }      // 添加到数组中      _parts.add(peiPart);    }  }    @override  Widget build(BuildContext context) {    return Column(      mainAxisAlignment: MainAxisAlignment.center,      children: [        Container(          width: 300,          height: 300,          child: CustomPaint(            // 将数据传给 PeiChartPainter            painter: PeiChartPainter(              total: _total,              parts: _parts,              datas: widget.datas,              legends: widget.legends,            ),          ),        ),      ],    );  }}</code></pre><p>在 PeiChartPainter 上添加 <code>drawLegends</code> 方法，在圆框的外围绘制每部分对应的标识。</p><pre><code class="dart">void drawLegends(Canvas canvas, Size size) {  final sw = size.width;  final sh = size.height;  final double radius = math.min(sw, sh) / 2;  final double fontSize = 12.0;  for (int i = 0; i &lt; datas.length; i++) {    final PiePart part = parts[i];    final String legend = legends[i];    // 根据每部分的起始弧度加上自身弧度值的一半得到每部分的中间弧度值    final radians = part.startAngle + part.sweepAngle / 2;    // 根据三角函数计算中出标识文字的 x 和 y 位置，需要加上宽和高的一半适配 Canvas 的坐标    double x = math.cos(radians) * (radius + 32) + sw / 2 - fontSize;    double y = math.sin(radians) * (radius + 32) + sh / 2;    final offset = Offset(x, y);    // 使用 TextPainter 绘制文字标识    TextPainter(      textAlign: TextAlign.center,      text: TextSpan(        text: legend,        style: TextStyle(          fontSize: fontSize,          color: Colors.black,        ),      ),      textDirection: TextDirection.ltr,    )      ..layout(        minWidth: 0,        maxWidth: size.width,      )      ..paint(canvas, offset);  }}@overridevoid paint(Canvas canvas, Size size) {  drawCircle(canvas, size);  drawLegends(canvas, size);}</code></pre><img src="./images/flutter-pie-chart/legend.png" width="520" style="width:260px"><p>计算文字位置用到的的三角函数是</p><p><img src="./images/flutter-pie-chart/angle.png" alt="angle"></p><h2 id="绘制数据对应的弧形"><a href="#绘制数据对应的弧形" class="headerlink" title="绘制数据对应的弧形"></a>绘制数据对应的弧形</h2><p>在 <code>PeiChartPainter</code> 上添加 <code>drawParts</code> 方法，绘制每个数据对应的弧形。</p><pre><code class="dart">void drawParts(Canvas canvas, Size size) {  final sw = size.width;  final sh = size.height;  final double fontSize = 10.0;  final double radius = math.min(sw, sh) / 2;  final Offset center = Offset(sw / 2, sh / 2);  // 创建弧形依照的矩形  final rect = Rect.fromCenter(    center: center,    width: radius * 2,    height: radius * 2,  );  // 设置绘制属性  final paint = Paint()    ..strokeWidth = 0.0    ..isAntiAlias = true    ..style = PaintingStyle.fill;  for (int i = 0; i &lt; parts.length; i++) {    final PiePart part = parts[i];    // 设置每部分的颜色    paint.color = part.color;    // 使用 drawArc 方法画出弧形，参数依次是依照的矩形，起始弧度值，占据的弧度值，是否从中心点绘制，绘制属性    canvas.drawArc(rect, part.startAngle, part.sweepAngle, true, paint);    final double data = datas[i];    // 计算每部分占比    final String percent = (data / total * 100).toStringAsFixed(1);    final double radians = part.startAngle + part.sweepAngle / 2;    // 使用三角函数计算文字位置    double x = math.cos(radians) * radius / 2 + sw / 2 - fontSize * 3;    double y = math.sin(radians) * radius / 2 + sh / 2;    final Offset offset = Offset(x, y);    // 使用 TextPainter 绘制文字标识    TextPainter(      textAlign: TextAlign.start,      text: TextSpan(        text: &#39;$data $percent%&#39;,        style: TextStyle(          fontSize: fontSize,          color: Colors.white,          fontWeight: FontWeight.bold,        ),      ),      textDirection: TextDirection.ltr,    )      ..layout(        minWidth: 0,        maxWidth: size.width,      )      ..paint(canvas, offset);  }}@overridevoid paint(Canvas canvas, Size size) {  drawCircle(canvas, size);  drawLegends(canvas, size);  drawParts(canvas, size);}</code></pre><img src="./images/flutter-pie-chart/part.png" width="520" style="width:260px"><h2 id="添加动画"><a href="#添加动画" class="headerlink" title="添加动画"></a>添加动画</h2><p>最后给饼图添加一个数据不断增长的动画效果，在 <code>_PieChartState</code> 添加动画的控制器 <code>_controller</code> 和保存动画数据的 <code>_animateDatas</code> 数组。在 <code>initState</code> 中初始化动画控制器和填充 <code>_animateDatas</code> 数组。然后创建两个 <code>double</code> 类型的补间动画，将动画值传给 <code>PeiChartPainter</code> 使用即可。</p><pre><code class="dart">class _PieChartState extends State&lt;PieChart&gt; with TickerProviderStateMixin {  double _total = 0.0;  AnimationController _controller;  List&lt;double&gt; _animateDatas = [];  final List&lt;PiePart&gt; _parts = &lt;PiePart&gt;[];  @override  void initState() {    super.initState();    // 初始化动画控制器    _controller = AnimationController(      duration: Duration(milliseconds: 3000),      vsync: this,    );    List&lt;double&gt; datas = widget.datas;    // 计算出数据总和    _total = datas.reduce((a, b) =&gt; a + b);    // 设置一个起始变量    double startAngle = 0.0;    for (int i = 0; i &lt; datas.length; i++) {      // 填充动画数组      _animateDatas.add(0.0);      final data = datas[i];      // 计算出每个数据所占的弧度值      final angle = (data / _total) * -math.pi * 2;      PiePart peiPart;      if (i &gt; 0) {        // 下一个数据的起始弧度值等于之前的弧度值相加        double lastSweepAngle = _parts[i - 1].sweepAngle;        startAngle += lastSweepAngle;        peiPart = PiePart(startAngle, angle, colors[i]);      } else {        // 第一个数据的起始弧度为 0.0        peiPart = PiePart(0.0, angle, colors[i]);      }      // 添加到数组中      _parts.add(peiPart);      CurvedAnimation curvedAnimation = CurvedAnimation(        parent: _controller,        curve: Curves.ease,      );      // 创建弧形的补间动画      final partTween = Tween&lt;double&gt;(begin: 0.0, end: peiPart.sweepAngle);      Animation&lt;double&gt; animation = partTween.animate(curvedAnimation);      // 创建文字的补间动画      final percentTween = Tween&lt;double&gt;(begin: 0.0, end: data);      Animation&lt;double&gt; percentAnimation =          percentTween.animate(curvedAnimation);      // 在动画启动后不断改变数据值      _controller.addListener(() {        _parts[i].sweepAngle = animation.value;        _animateDatas[i] =            double.parse(percentAnimation.value.toStringAsFixed(1));        setState(() {});      });      // 开始动画      _controller.forward();    }  }  @override  Widget build(BuildContext context) {    return Column(      mainAxisAlignment: MainAxisAlignment.center,      children: [        Container(          width: 300,          height: 300,          child: CustomPaint(            // 将数据传给 PeiChartPainter            painter: PeiChartPainter(              total: _total,              parts: _parts,              datas: _animateDatas,              legends: widget.legends,            ),          ),        ),        SizedBox(height: 80),        Container(          decoration: BoxDecoration(            color: Colors.blue,            shape: BoxShape.circle,          ),          child: IconButton(            color: Colors.white,            icon: Icon(Icons.refresh),            onPressed: () {              _controller.reset();              _controller.forward();            },          ),        ),      ],    );  }}</code></pre><p>至此整个饼状图的绘制就完成了，传入数据即可使用 🎉🎉🎉</p><pre><code class="dart">PieChart(  datas: [60.0, 50.0, 40.0, 30.0, 90.0],  legends: [&#39;一月&#39;, &#39;二月&#39;, &#39;三月&#39;, &#39;四月&#39;, &#39;五月&#39;],);</code></pre><p>完整代码地址：<a href="https://github.com/xrr2016/flutter-charts/blob/master/lib/charts/pie_chart.dart" target="_blank" rel="noopener">pie_chart.dart</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文说明了如何使用 Flutter 绘制一个饼状图，使用了一点三角函数，关键点在于计算出每个数据占据整个圆形的弧度值，以及数据的起始弧度值。<br>数值增长的动画效果使用一个 <code>AnimationController</code> 在开始动画后不断的更新绘制使用的数据，在将数据传递给 <code>PeiChartPainter</code> 使用即可实现。</p><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>准备写一系列关于用 Flutter 画图表的文章，用来分享这方面的知识，这篇文章是这个系列的第二篇，预计 6 篇。</p><ol><li><a href="https://coldstone.fun/post/2020/05/31/flutter-bar-chart/">使用 Flutter 绘制图表（一）柱状图📊</a></li><li><a href="https://coldstone.fun/post/2020/06/09/flutter-pie-chart/">使用 Flutter 绘制图表（二）饼状图🍪</a>（本文）</li><li>使用 Flutter 绘制图表（三）折线图📈</li><li>使用 Flutter 绘制图表（四）雷达图🎯</li><li>使用 Flutter 绘制图表（五）环状图🍩</li><li>使用 Flutter 绘制图表（六）条形图📏</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/flutter-pie-chart/cover.png&quot; alt=&quot;pie&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>使用 Flutter 绘制图表（一）柱状图📊</title>
    <link href="https://coldstone.fun/post/2020/05/31/flutter-bar-chart/"/>
    <id>https://coldstone.fun/post/2020/05/31/flutter-bar-chart/</id>
    <published>2020-05-31T14:00:00.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/flutter-bar-chart/cover.png" alt="bar"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲解如何使用 <a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter</a> （Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台） 绘制一个带有动画效果的柱状图表，最终效果如下图。</p><img src="./images/flutter-bar-chart/bar-chart.gif" width="568" style="width:260px"><p>要绘制这样的图表普通的 Widget 难以实现，这时就需要 <code>CustomPaint</code> 和 <code>CustomPainter</code> 出场了，它们类似于 Web 里面的 <code>&lt;canvas&gt;</code> 元素，<code>CustomPaint</code> 提供了一个绘制区域，而 <code>CustomPainter</code> 拥有具体的绘制方法。</p><h2 id="CustomPaint-是什么"><a href="#CustomPaint-是什么" class="headerlink" title="CustomPaint 是什么"></a>CustomPaint 是什么</h2><p><code>CustomPaint</code> 是用来提供画布的控件，它使用传入画笔 <code>painter</code> 在 <code>child</code> 控件后面绘制图形, ，<code>foregroundPainter</code> 画笔绘制在 <code>child</code> 控件之前。<code>size</code> 属性控制画布的大小，假如定义了子控件 <code>child</code>，那么画布的大小将由子控件的大小决定，<code>size</code> 属性被忽略。</p><pre><code class="dart">class CustomPaint extends SingleChildRenderObjectWidget {  const CustomPaint({    Key key,    this.painter,    this.foregroundPainter,    this.size = Size.zero,    this.isComplex = false,    this.willChange = false,    Widget child,  })}</code></pre><p>而 <code>CustomPainter</code> 是实现绘制图形的控件，要在画布上绘制图形需要实现它的 <code>paint</code> 方法。<code>paint</code> 方法有两个参数，<code>Canvas canvas</code> 和 <code>Size size</code>。<code>Size</code> 对象表示画布的尺寸，<code>Canvas</code> 对象上是具体的绘制图形的方法。</p><pre><code class="dart">abstract class CustomPainter extends Listenable {  void paint(Canvas canvas, Size size);  bool shouldRepaint(covariant CustomPainter oldDelegate);}</code></pre><p><code>Canvas canvas</code> 对象主要的绘制图形方法有</p><table><thead><tr><th align="left">方法名</th><th align="left">参数</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left"><code>drawColor</code></td><td align="left"><code>Color color</code>, <code>BlendMode blendMode</code></td><td align="left">绘制颜色到画布上</td></tr><tr><td align="left"><code>drawLine</code></td><td align="left"><code>Offset p1</code>, <code>Offset p2</code>, <code>Paint paint</code></td><td align="left">两点之间画线</td></tr><tr><td align="left"><code>drawPaint</code></td><td align="left"><code>Paint paint</code></td><td align="left">使用 [Paint] 填充画布</td></tr><tr><td align="left"><code>drawRect</code></td><td align="left"><code>Rect rect</code>, <code>Paint paint</code></td><td align="left">绘制矩形</td></tr><tr><td align="left"><code>drawRRect</code></td><td align="left"><code>RRect rrect</code>, <code>Paint paint</code></td><td align="left">绘制带圆角的矩形</td></tr><tr><td align="left"><code>drawOval</code></td><td align="left"><code>Rect rect</code>, <code>Paint paint</code></td><td align="left">绘制椭圆</td></tr><tr><td align="left"><code>drawCircle</code></td><td align="left"><code>Offset c</code>, <code>double radius</code>, <code>Paint paint</code></td><td align="left">绘制圆形</td></tr><tr><td align="left"><code>drawArc</code></td><td align="left"><code>Rect rect</code>, <code>double startAngle</code>, <code>double sweepAngle</code>, <code>bool useCenter</code>, <code>Paint paint</code></td><td align="left">绘制弧形</td></tr><tr><td align="left"><code>drawPath</code></td><td align="left"><code>Path path</code>, <code>Paint paint</code></td><td align="left">绘制路径</td></tr><tr><td align="left"><code>drawImage</code></td><td align="left"><code>Image image</code>, <code>Offset p</code>, <code>Paint paint</code></td><td align="left">绘制图像</td></tr><tr><td align="left"><code>drawPoints</code></td><td align="left"><code>PointMode pointMode</code>, <code>List&lt;Offset&gt; points</code>, <code>Paint paint</code></td><td align="left">绘制多个点</td></tr></tbody></table><p>要将图形绘制到画布上需要先创建一个继承至 <code>CustomPainter</code> 的自定义画笔，例如绘制一个矩形需要实现一个绘制矩形的画笔 <code>RectanglePainter</code>，然后在画布 <code>CustomPaint</code> 上应用它。</p><pre><code class="dart">class RectanglePainter extends CustomPainter {  @override  void paint(Canvas canvas, Size size) {    // 定义一个矩形    final Rect rect = Rect.fromLTWH(50.0, 50.0, 100.0, 100.0);    // 指定绘制的样式    final Paint paint = Paint()      ..color = Colors.orange      ..strokeWidth = 4.0      ..style = PaintingStyle.stroke      ..isAntiAlias = true;    // 使用 drawRect 绘制矩形    canvas.drawRect(rect, paint);  }  @override  bool shouldRepaint(RectanglePainter oldDelegate) =&gt; false;}class Rectangle extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Center(      child: CustomPaint(        // 使用 RectanglePainter 在画布上绘制        painter: RectanglePainter(),        child: Container(          width: 300,          height: 300,          decoration: BoxDecoration(            border: Border.all(              width: 1.0,              color: Colors.grey[300],            ),          ),        ),      ),    );  }}</code></pre><p>效果如图</p><img src="./images/flutter-bar-chart/rect.png" width="520" style="width:260px"><h2 id="绘制柱状图表"><a href="#绘制柱状图表" class="headerlink" title="绘制柱状图表"></a>绘制柱状图表</h2><p>介绍完毕，下面开始绘制柱状图表，第一步创建 <code>BarChart</code> 控件代表柱状图，它有两个构造参数一个是 <code>data</code> 用来接收图表数据，以及 <code>xAxis</code> 表示图表横轴标识。</p><pre><code class="dart">class BarChart extends StatefulWidget {  final List&lt;double&gt; data;  final List&lt;String&gt; xAxis;  const BarChart({    @required this.data,    @required this.xAxis,  });  @override  _BarChartState createState() =&gt; _BarChartState();}class _BarChartState extends State&lt;BarChart&gt; with TickerProviderStateMixin {  @override  Widget build(BuildContext context) {    return Column(      mainAxisAlignment: MainAxisAlignment.center,      children: [        CustomPaint(          painter: BarChartPainter(            datas: widget.data,            xAxis: widget.xAxis,          ),          child: Container(width: 300, height: 300),        ),      ],    );  }}</code></pre><p>然后创建一个用来绘制的自定义画笔 <code>BarChartPainter</code>。</p><pre><code class="dart">class BarChartPainter extends CustomPainter {  final List&lt;double&gt; datas;  final List&lt;String&gt; xAxis;  BarChartPainter({    @required this.xAxis,    @required this.datas,  });   @override  void paint(Canvas canvas, Size size) {    // TODO  }  @override  bool shouldRepaint(BarChartPainter oldDelegate) =&gt; true;  @override  bool shouldRebuildSemantics(BarChartPainter oldDelegate) =&gt; false;}</code></pre><h3 id="绘制坐标轴"><a href="#绘制坐标轴" class="headerlink" title="绘制坐标轴"></a>绘制坐标轴</h3><p>在 <code>BarChartPainter</code> 上定义一个 <code>_drawAxis</code> 方法用于绘制横坐标轴，使用一个由左上，左下，右下三个点控制的 <code>Path</code> 路径绘制。</p><pre><code class="dart">void _drawAxis(Canvas canvas, Size size) {  final double sw = size.width;  final double sh = size.height;  // 使用 Paint 定义路径的样式  final Paint paint = Paint()    ..color = Colors.black87    ..style = PaintingStyle.stroke    ..strokeWidth = 1.0;  // 使用 Path 定义绘制的路径，从画布的左上角到左下角在到右下角  final Path path = Path()    ..moveTo(0, 0)    ..lineTo(0, sh)    ..lineTo(sw, sh);  // 使用 drawPath 方法绘制路径  canvas.drawPath(path, paint);}@overridevoid paint(Canvas canvas, Size size) {  _drawAxis(canvas, size);}</code></pre><p>效果如下</p><img src="./images/flutter-bar-chart/chart-axis.png" width="508" style="width:260px" alt="chart-axis"><h3 id="绘制标识"><a href="#绘制标识" class="headerlink" title="绘制标识"></a>绘制标识</h3><p>在 <code>BarChartPainter</code> 上定义一个 <code>_drawLabels</code> 方法绘制纵轴标识。</p><pre><code class="dart">void _drawLabels(Canvas canvas, Size size) {  final double gap = 50.0;  final double sh = size.height;  final List&lt;double&gt; yAxisLabels = [];  Paint paint = Paint()    ..color = Colors.black87    ..strokeWidth = 2.0;  // 使用 50.0 为间隔绘制比传入数据多一个的标识  for (int i = 0; i &lt;= datas.length; i++) {    yAxisLabels.add(gap * i);  }  yAxisLabels.asMap().forEach(    (index, label) {      // 标识的高度为画布高度减去标识的值      final double top = sh - label;      final rect = Rect.fromLTWH(0, top, 4, 1);      final Offset textOffset = Offset(        0 - labelFontSize * 3,        top - labelFontSize / 2,      );      // 绘制 Y 轴右边的线条      canvas.drawRect(rect, paint);      // 绘制文字需要用 `TextPainter`，最后调用 paint 方法绘制文字      TextPainter(        text: TextSpan(          text: label.toStringAsFixed(0),          style: TextStyle(fontSize: labelFontSize, color: Colors.black87),        ),        textAlign: TextAlign.right,        textDirection: TextDirection.ltr,        textWidthBasis: TextWidthBasis.longestLine,      )        ..layout(minWidth: 0, maxWidth: 24)        ..paint(canvas, textOffset);    },  );}@overridevoid paint(Canvas canvas, Size size) {  _drawAxis(canvas, size);  _drawLabels(canvas, size);}</code></pre><p>效果如下</p><img src="./images/flutter-bar-chart/chart-yaxis.png" width="520" style="width:260px" alt="chart-yaxis"><h3 id="绘制数据矩形"><a href="#绘制数据矩形" class="headerlink" title="绘制数据矩形"></a>绘制数据矩形</h3><p>然后定义一个 <code>_darwBars</code> 方法将具体矩形和横轴标识绘制出来。</p><pre><code class="dart">List&lt;Color&gt; colors = [  Color(0xff8e43e7),  Color(0xffff4f81),  Color(0xff1cc7d0),  Color(0xff00aeff),  Color(0xff3369e7),  Color(0xffb84592),  Color(0xff2dde98),  Color(0xffff6c5f),  Color(0xff003666),  Color(0xffffc168),  Color(0xff050f2c),];void _darwBars(Canvas canvas, Size size) {  final sh = size.height;  final paint = Paint()..style = PaintingStyle.fill;  for (int i = 0; i &lt; datas.length; i++) {    // 每个矩形使用预设的 colors 数组里面的颜色    paint.color = colors[i];    final double textFontSize = 14.0;    final double data = datas[i];    // 矩形的上边缘为画布高度减去数据值    final double top = sh - data;    // 矩形的左边缘为当前索引值乘以矩形宽度加上矩形之间的间距    final double left = i * _barWidth + (i * _barGap) + _barGap;    // 使用 Rect.fromLTWH 方法创建要绘制的矩形    final rect = Rect.fromLTWH(left, top, _barWidth, data);    // 使用 drawRect 方法绘制矩形    canvas.drawRect(rect, paint);    final offset = Offset(      left + _barWidth / 2 - textFontSize * 1.2,      top - textFontSize * 2,    );    // 使用 TextPainter 绘制矩形上放的数值    TextPainter(      text: TextSpan(        text: data.toStringAsFixed(1),        style: TextStyle(fontSize: textFontSize, color: paint.color),      ),      textAlign: TextAlign.center,      textDirection: TextDirection.ltr,    )      ..layout(        minWidth: 0,        maxWidth: textFontSize * data.toString().length,      )      ..paint(canvas, offset);    final xData = xAxis[i];    final xOffset = Offset(left + _barWidth / 2 - textFontSize, sh + 12);    // 绘制横轴标识    TextPainter(      textAlign: TextAlign.center,      text: TextSpan(        text: &#39;$xData&#39;,        style: TextStyle(fontSize: 12, color: Colors.black87),      ),      textDirection: TextDirection.ltr,    )      ..layout(        minWidth: 0,        maxWidth: size.width,      )      ..paint(canvas, xOffset);  }}@overridevoid paint(Canvas canvas, Size size) {  _drawAxis(canvas, size);  _drawLabels(canvas, size);  _darwBars(canvas, size);}</code></pre><p>效果如下</p><img src="./images/flutter-bar-chart/chart-data.png" width="520" style="width:260px" alt="chart-data"><h3 id="添加运动动画"><a href="#添加运动动画" class="headerlink" title="添加运动动画"></a>添加运动动画</h3><p>最后在 <code>_BarChartState</code> 里使用一个 <code>AnimationController</code> 创建柱状图运动的动画，关于动画方面的知识可以查阅 <a href="https://coldstone.fun/post/2020/04/26/flutter-animation-from-zero/">从零开始的 Flutter 动画</a> 这篇文章。</p><pre><code class="dart">class _BarChartState extends State&lt;BarChart&gt; with TickerProviderStateMixin {  AnimationController _controller;  final _animations = &lt;double&gt;[];  @override  void initState() {    super.initState();    double begin = 0.0;    List&lt;double&gt; datas = widget.data;    // 初始化动画控制器，并调用 forward 方法启动动画    _controller = AnimationController(      vsync: this,      duration: Duration(milliseconds: 3000),    )..forward();    for (int i = 0; i &lt; datas.length; i++) {      final double end = datas[i];      // 使用一个补间值 Tween 创建每个矩形的动画值      final Tween&lt;double&gt; tween = Tween(begin: begin, end: end);      // 初始化数组里面的值      _animations.add(begin);      // 创建补间动画      Animation&lt;double&gt; animation = tween.animate(        CurvedAnimation(          parent: _controller,          curve: Curves.ease,        ),      );      _controller.addListener(() {        // 使用 setState 更新 _animations 数组里面的动画值        setState(() {          _animations[i] = animation.value;        });      });    }  }  @override  Widget build(BuildContext context) {    return Column(      mainAxisAlignment: MainAxisAlignment.center,      children: [        CustomPaint(          // 最后向 BarChartPainter 传入 _animations 数组，实现动画          painter: BarChartPainter(            datas: _animations,            xAxis: widget.xAxis,            animation: _controller,          ),          child: Container(width: 300, height: 300),        ),      ],    );  }}</code></pre><p>至此整个柱状图的绘制就完成了，传入数据即可使用 🎉🎉🎉</p><pre><code class="dart">BarChart(  data: [180.0, 98.0, 126.0, 64.0, 118.0],  xAxis: [&#39;一月&#39;, &#39;二月&#39;, &#39;三月&#39;, &#39;四月&#39;, &#39;五月&#39;],);</code></pre><p>完整代码地址：<a href="https://github.com/xrr2016/flutter-charts/blob/master/lib/charts/bar_chart.dart" target="_blank" rel="noopener">bar_chart.dart</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文说明了什么是 <code>CustomPaint</code> 和 <code>CustomPainter</code>。以及如何使用它们绘制一个带有动画的柱状图表。</p><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>准备写一系列关于用 Flutter 画图表的文章，用来分享这方面的知识，这篇文章是这个系列的开篇，预计一共会写 6 篇。</p><ol><li><a href="https://coldstone.fun/post/2020/05/31/flutter-bar-chart/">使用 Flutter 绘制图表（一）柱状图📊</a>（本文）</li><li>使用 Flutter 绘制图表（二）饼状图🍪</li><li>使用 Flutter 绘制图表（三）折线图📈</li><li>使用 Flutter 绘制图表（四）雷达图🎯</li><li>使用 Flutter 绘制图表（五）环状图🍩</li><li>使用 Flutter 绘制图表（六）条形图📏</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/flutter-bar-chart/cover.png&quot; alt=&quot;bar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>选择适合的 Flutter 动画控件</title>
    <link href="https://coldstone.fun/post/2020/05/07/flutter-animation-decision/"/>
    <id>https://coldstone.fun/post/2020/05/07/flutter-animation-decision/</id>
    <published>2020-05-07T02:04:58.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/flutter-animation-decision/level.png" alt="level"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 团队推出了一个关于 <a href="https://www.youtube.com/watch?v=GXIJJkq_H8g" target="_blank" rel="noopener">如何在 Flutter 中选择合适的动画 Widget</a> 的视频以及配套的文章 <a href="https://medium.com/flutter/how-to-choose-which-flutter-animation-widget-is-right-for-you-79ecfb7e72b5" target="_blank" rel="noopener">How to Choose Which Flutter Animation Widget is Right for You? </a>都挺有好的，所以将文中的选择图翻译出来。</p><h2 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h2><p><img src="./images/flutter-animation-decision/animation-decision-tree.png" alt="animation-decision-tree"></p><h2 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h2><p><img src="./images/flutter-animation-decision/animation-decision-tree-zh.png" alt="animation-decision-tree-zh"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/flutter/how-to-choose-which-flutter-animation-widget-is-right-for-you-79ecfb7e72b5" target="_blank" rel="noopener">How to Choose Which Flutter Animation Widget is Right for You?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/flutter-animation-decision/level.png&quot; alt=&quot;level&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
      <category term="Animation" scheme="https://coldstone.fun/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的 Flutter 动画</title>
    <link href="https://coldstone.fun/post/2020/04/26/flutter-animation-from-zero/"/>
    <id>https://coldstone.fun/post/2020/04/26/flutter-animation-from-zero/</id>
    <published>2020-04-26T12:00:00.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/flutter-animation-from-zero/cover.png" alt="cover"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动画本质是在一段时间内不断改变屏幕上显示的内容，从而产生<a href="https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A6%BA%E6%9A%AB%E7%95%99" target="_blank" rel="noopener">视觉暂留</a>现象。</p><p>动画一般可分为两类：</p><p><strong>补间动画</strong>：补间动画是一种预先定义物体运动的起点和终点，物体的运动方式，运动时间，时间曲线，然后从起点过渡到终点的动画。</p><p><strong>基于物理的动画</strong>：基于物理的动画是一种模拟现实世界运动的动画，通过建立运动模型来实现。例如一个篮球🏀从高处落下，需要根据其下落高度，重力加速度，地面反弹力等影响因素来建立运动模型。</p><h2 id="Flutter-中的动画"><a href="#Flutter-中的动画" class="headerlink" title="Flutter 中的动画"></a>Flutter 中的动画</h2><p>Flutter 中有多种类型的动画，先从一个简单的例子开始，使用一个 <code>AnimatedContainer</code> 控件，然后设置动画时长 <code>duration</code>，最后调用 <code>setState</code> 方法改变需要变化的属性值，一个动画就创建了。</p><img src="./images/flutter-animation-from-zero/animated-container.gif" alt="animated-container" style="width:240px" width="240"><p>代码如下</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class AnimatedContainerPage extends StatefulWidget {  @override  _AnimatedContainerPageState createState() =&gt; _AnimatedContainerPageState();}class _AnimatedContainerPageState extends State&lt;AnimatedContainerPage&gt; {  // 初始的属性值  double size = 100;  double raidus = 25;  Color color = Colors.yellow;  void _animate() {    // 改变属性值    setState(() {      size = size == 100 ? 200 : 100;      raidus = raidus == 25 ? 100 : 25;      color = color == Colors.yellow ? Colors.greenAccent : Colors.yellow;    });  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;Animated Container&#39;)),      body: Center(        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          children: [            // 在 AnimatedContainer 上应用属性值            AnimatedContainer(              width: size,              height: size,              curve: Curves.easeIn,              padding: const EdgeInsets.all(20.0),              decoration: BoxDecoration(                color: color,                borderRadius: BorderRadius.circular(raidus),              ),              duration: Duration(seconds: 1),              child: FlutterLogo(),            )          ],        ),      ),      floatingActionButton: FloatingActionButton(        onPressed: _animate,        child: Icon(Icons.refresh),      ),    );  }}</code></pre><p>这是一个隐式动画，除此之外还有显式动画，Hreo 动画，交织动画。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Flutter 动画是建立在以下的概念之上。</p><p><code>Animation</code></p><p>Flutter 中的动画系统基于 <code>Animation</code> 对象， 它是一个抽象类，保存了当前动画的值和状态（开始、暂停、前进、倒退），但不记录屏幕上显示的内容。UI 元素通过读取 <code>Animation</code> 对象的值和监听状态变化运行 <code>build</code> 函数，然后渲染到屏幕上形成动画效果。</p><p>一个 <code>Animation</code> 对象在一段时间内会持续生成介于两个值之间的值，比较常见的类型是 <code>Animation&lt;double&gt;</code>，除 <code>double</code> 类型之外还有 <code>Animation&lt;Color&gt;</code> 或者 <code>Animation&lt;Size&gt;</code> 等。</p><pre><code class="dart">abstract class Animation&lt;T&gt; extends Listenable implements ValueListenable&lt;T&gt; {  /// ...}</code></pre><p><code>AnimationController</code></p><p>带有控制方法的 <code>Animation</code> 对象，用来控制动画的启动，暂停，结束，设定动画运行时间等。</p><pre><code class="dart">class AnimationController extends Animation&lt;double&gt;  with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin {  /// ...}AnimationController controller = AnimationController(  vsync: this,  duration: Duration(seconds: 10),);</code></pre><p><code>Tween</code></p><p>用来生成不同类型和范围的动画取值。</p><pre><code class="dart">class Tween&lt;T extends dynamic&gt; extends Animatable&lt;T&gt; {  Tween({ this.begin, this.end });  /// ...}// double 类型Tween&lt;double&gt; tween = Tween&lt;double&gt;(begin: -200, end: 200);// color 类型ColorTween colorTween = ColorTween(begin: Colors.blue, end: Colors.yellow);// border radius 类型BorderRadiusTween radiusTween = BorderRadiusTween(  begin: BorderRadius.circular(0.0),  end: BorderRadius.circular(150.0),);</code></pre><p><code>Curve</code></p><p>Flutter 动画的默认动画过程是匀速的，使用 <code>CurvedAnimation</code> 可以将时间曲线定义为非线性曲线。</p><pre><code class="dart">class CurvedAnimation extends Animation&lt;double&gt; with AnimationWithParentMixin&lt;double&gt; {  /// ...}Animation animation = CurvedAnimation(parent: controller, curve: Curves.easeIn);</code></pre><p><code>Ticker</code></p><p><code>Ticker</code> 用来添加每次屏幕刷新的回调函数 <code>TickerCallback</code>，每次屏幕刷新都会调用。类似于 Web 里面的 <code>requestAnimationFrame</code> 方法。</p><pre><code class="dart">class Ticker {  /// ...}Ticker ticker = Ticker(callback);</code></pre><h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>隐式动画使用 Flutter 框架内置的动画部件创建，通过设置动画的起始值和最终值来触发。当使用 <code>setState</code> 方法改变部件的动画属性值时，框架会自动计算出一个从旧值过渡到新值的动画。</p><p>比如 <code>AnimatedOpacity</code> 部件，改变它的 <code>opacity</code> 值就可以触发动画。</p><img src="./images/flutter-animation-from-zero/opacity-toggle.gif" alt="opacity-toggle" style="width:240px" width="240"><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class OpacityChangePage extends StatefulWidget {  @override  _OpacityChangePageState createState() =&gt; _OpacityChangePageState();}class _OpacityChangePageState extends State&lt;OpacityChangePage&gt; {  double _opacity = 1.0;  // 改变目标值  void _toggle() {    _opacity = _opacity &gt; 0 ? 0.0 : 1.0;    setState(() {});  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;隐式动画&#39;)),      body: Center(        child: AnimatedOpacity(          // 传入目标值          opacity: _opacity,          duration: Duration(seconds: 1),          child: Container(            width: 200,            height: 200,            color: Colors.blue,          ),        ),      ),      floatingActionButton: FloatingActionButton(        onPressed: _toggle,        child: Icon(Icons.play_arrow),      ),    );  }}</code></pre><p>除了 <code>AnimatedOpacity</code> 外，还有其他的内置隐式动画部件如：<code>AnimatedContainer</code>, <code>AnimatedPadding</code>, <code>AnimatedPositioned</code>, <code>AnimatedSwitcher</code>， <code>AnimatedAlign</code> 等。</p><h2 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h2><p>显式动画指的是需要手动设置动画的时间，运动曲线，取值范围的动画。将值传递给动画部件如: <code>RotationTransition</code>，最后使用一个<code>AnimationController</code> 控制动画的开始和结束。</p><img src="./images/flutter-animation-from-zero/explicit-animation.gif" alt="explicit-animation" style="width:240px" width="240"><pre><code class="dart">import &#39;dart:math&#39;;import &#39;package:flutter/material.dart&#39;;class RotationAinmationPage extends StatefulWidget {  @override  _RotationAinmationPageState createState() =&gt; _RotationAinmationPageState();}class _RotationAinmationPageState extends State&lt;RotationAinmationPage&gt;    with SingleTickerProviderStateMixin {  AnimationController _controller;  Animation&lt;double&gt; _turns;  bool _playing = false;  // 控制动画运行状态  void _toggle() {    if (_playing) {      _playing = false;      _controller.stop();    } else {      _controller.forward()..whenComplete(() =&gt; _controller.reverse());      _playing = true;    }    setState(() {});  }  @override  void initState() {    super.initState();    // 初始化动画控制器，设置动画时间    _controller = AnimationController(      vsync: this,      duration: Duration(seconds: 10),    );    // 设置动画取值范围和时间曲线    _turns = Tween(begin: 0.0, end: pi * 2).animate(      CurvedAnimation(parent: _controller, curve: Curves.easeIn),    );  }  @override  void dispose() {    super.dispose();    _controller.dispose();  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;显示动画&#39;)),      body: Center(        child: RotationTransition(          // 传入动画值          turns: _turns,          child: Container(            width: 200,            height: 200,            child: Image.asset(              &#39;assets/images/fan.png&#39;,              fit: BoxFit.cover,            ),          ),        ),      ),      floatingActionButton: FloatingActionButton(        onPressed: _toggle,        child: Icon(_playing ? Icons.pause : Icons.play_arrow),      ),    );  }}</code></pre><p>除了 <code>RotationTransition</code> 外，还有其他的显示动画部件如：<code>FadeTransition</code>, <code>ScaleTransition</code>, <code>SizeTransition</code>, <code>SlideTransition</code> 等。</p><h2 id="Hero-动画"><a href="#Hero-动画" class="headerlink" title="Hero 动画"></a>Hero 动画</h2><p>Hero 动画指的是在页面切换时一个元素从旧页面运动到新页面的动画。Hero 动画需要使用两个 <code>Hero</code> 控件实现：一个用来在旧页面中，另一个在新页面。两个 <code>Hero</code> 控件需要使用相同的 <code>tag</code> 属性，并且不能与其他<code>tag</code>重复。</p><img src="./images/flutter-animation-from-zero/hero-animation.gif" alt="hero-animation" style="width:240px" width="240"><pre><code class="dart">// 页面 1import &#39;package:flutter/material.dart&#39;;import &#39;hero_animation_page2.dart&#39;;String cake1 = &#39;assets/images/cake01.jpg&#39;;String cake2 = &#39;assets/images/cake02.jpg&#39;;class HeroAnimationPage1 extends StatelessWidget {  GestureDetector buildRowItem(context, String image) {    return GestureDetector(      onTap: () {        // 跳转到页面 2        Navigator.of(context).push(          MaterialPageRoute(builder: (ctx) {            return HeroAnimationPage2(image: image);          }),        );      },      child: Container(        width: 100,        height: 100,        child: Hero(          // 设置 Hero 的 tag 属性          tag: image,          child: ClipOval(child: Image.asset(image)),        ),      ),    );  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;页面 1&#39;)),      body: Column(        children: &lt;Widget&gt;[          SizedBox(height: 40.0),          Row(            mainAxisAlignment: MainAxisAlignment.spaceAround,            children: &lt;Widget&gt;[              buildRowItem(context, cake1),              buildRowItem(context, cake2),            ],          ),        ],      ),    );  }}// 页面 2import &#39;package:flutter/material.dart&#39;;class HeroAnimationPage2 extends StatelessWidget {  final String image;  const HeroAnimationPage2({@required this.image});  @override  Widget build(BuildContext context) {    return Scaffold(      body: CustomScrollView(        slivers: &lt;Widget&gt;[          SliverAppBar(            expandedHeight: 400.0,            title: Text(&#39;页面 2&#39;),            backgroundColor: Colors.grey[200],            flexibleSpace: FlexibleSpaceBar(              collapseMode: CollapseMode.parallax,              background: Hero(                // 使用从页面 1 传入的 tag 值                tag: image,                child: Container(                  decoration: BoxDecoration(                    image: DecorationImage(                      image: AssetImage(image),                      fit: BoxFit.cover,                    ),                  ),                ),              ),            ),          ),          SliverList(            delegate: SliverChildListDelegate(              &lt;Widget&gt;[                Container(height: 600.0, color: Colors.grey[200]),              ],            ),          ),        ],      ),    );  }}</code></pre><h2 id="交织动画"><a href="#交织动画" class="headerlink" title="交织动画"></a>交织动画</h2><p>交织动画是由一系列的小动画组成的动画。每个小动画可以是连续或间断的，也可以相互重叠。其关键点在于使用 <code>Interval</code> 部件给每个小动画设置一个时间间隔，以及为每个动画的设置一个取值范围 <code>Tween</code>，最后使用一个 <code>AnimationController</code> 控制总体的动画状态。</p><p><code>Interval</code> 继承至 <code>Curve</code> 类，通过设置属性 <code>begin</code> 和 <code>end</code> 来确定这个小动画的运行范围。</p><pre><code class="dart">class Interval extends Curve {  /// ...  /// 动画起始点  final double begin;  /// 动画结束点  final double end;  /// 动画缓动曲线  final Curve curve;  /// ...}</code></pre><img src="./images/flutter-animation-from-zero/staggered-animation.gif" alt="staggered-animation" style="width:240px" width="240"><p>这是一个由 5 个小动画组成的交织动画，宽度，高度，颜色，圆角，边框，每个动画都有自己的动画区间。</p><p><img src="./images/flutter-animation-from-zero/staggered-animation-timeline.png" alt="staggered-animation-timeline"></p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class StaggeredAnimationPage extends StatefulWidget {  @override  _StaggeredAnimationPageState createState() =&gt; _StaggeredAnimationPageState();}class _StaggeredAnimationPageState extends State&lt;StaggeredAnimationPage&gt;    with SingleTickerProviderStateMixin {  AnimationController _controller;  Animation&lt;double&gt; _width;  Animation&lt;double&gt; _height;  Animation&lt;Color&gt; _color;  Animation&lt;double&gt; _border;  Animation&lt;BorderRadius&gt; _borderRadius;  void _play() {    if (_controller.isCompleted) {      _controller.reverse();    } else {      _controller.forward();    }  }  @override  void initState() {    super.initState();    _controller = AnimationController(      vsync: this,      duration: Duration(seconds: 5),    );    _width = Tween&lt;double&gt;(      begin: 100,      end: 300,    ).animate(      CurvedAnimation(        parent: _controller,        curve: Interval(          0.0,          0.2,          curve: Curves.ease,        ),      ),    );    _height = Tween&lt;double&gt;(      begin: 100,      end: 300,    ).animate(      CurvedAnimation(        parent: _controller,        curve: Interval(          0.2,          0.4,          curve: Curves.ease,        ),      ),    );    _color = ColorTween(      begin: Colors.blue,      end: Colors.yellow,    ).animate(      CurvedAnimation(        parent: _controller,        curve: Interval(          0.4,          0.6,          curve: Curves.ease,        ),      ),    );    _borderRadius = BorderRadiusTween(      begin: BorderRadius.circular(0.0),      end: BorderRadius.circular(150.0),    ).animate(      CurvedAnimation(        parent: _controller,        curve: Interval(          0.6,          0.8,          curve: Curves.ease,        ),      ),    );    _border = Tween&lt;double&gt;(      begin: 0,      end: 25,    ).animate(      CurvedAnimation(        parent: _controller,        curve: Interval(0.8, 1.0),      ),    );  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;交织动画&#39;)),      body: Center(        child: AnimatedBuilder(          animation: _controller,          builder: (BuildContext context, Widget child) {            return Container(              width: _width.value,              height: _height.value,              decoration: BoxDecoration(                color: _color.value,                borderRadius: _borderRadius.value,                border: Border.all(                  width: _border.value,                  color: Colors.orange,                ),              ),            );          },        ),      ),      floatingActionButton: FloatingActionButton(        onPressed: _play,        child: Icon(Icons.refresh),      ),    );  }}</code></pre><h2 id="物理动画"><a href="#物理动画" class="headerlink" title="物理动画"></a>物理动画</h2><p>物理动画是一种模拟现实世界物体运动的动画。需要建立物体的运动模型，以一个物体下落为例，这个运动受到物体的下落高度，重力加速度，地面的反作用力等因素的影响。</p><img src="./images/flutter-animation-from-zero/throw-animation.gif" alt="throw-animation" style="width:240px" width="240"><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:flutter/scheduler.dart&#39;;class ThrowAnimationPage extends StatefulWidget {  @override  _ThrowAnimationPageState createState() =&gt; _ThrowAnimationPageState();}class _ThrowAnimationPageState extends State&lt;ThrowAnimationPage&gt; {  // 球心高度  double y = 70.0;  // Y 轴速度  double vy = -10.0;  // 重力  double gravity = 0.1;  // 地面反弹力  double bounce = -0.5;  // 球的半径  double radius = 50.0;  // 地面高度  final double height = 700;  // 下落方法  void _fall(_) {    y += vy;    vy += gravity;    // 如果球体接触到地面，根据地面反弹力改变球体的 Y 轴速度    if (y + radius &gt; height) {      y = height - radius;      vy *= bounce;    } else if (y - radius &lt; 0) {      y = 0 + radius;      vy *= bounce;    }    setState(() {});  }  @override  void initState() {    super.initState();    // 使用一个 Ticker 在每次更新界面时运行球体下落方法    Ticker(_fall)..start();  }  @override  Widget build(BuildContext context) {    double screenWidth = MediaQuery.of(context).size.width;    return Scaffold(      appBar: AppBar(title: Text(&#39;物理动画&#39;)),      body: Column(        children: &lt;Widget&gt;[          Container(            height: height,            child: Stack(              children: &lt;Widget&gt;[                Positioned(                  top: y - radius,                  left: screenWidth / 2 - radius,                  child: Container(                    width: radius * 2,                    height: radius * 2,                    decoration: BoxDecoration(                      color: Colors.blue,                      shape: BoxShape.circle,                    ),                  ),                ),              ],            ),          ),          Expanded(child: Container(color: Colors.blue)),        ],      ),    );  }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Flutter 中多种类型的动画，分别是</p><ul><li>隐式动画</li><li>显式动画</li><li>Hero 动画</li><li>交织动画</li><li>基于物理的动画</li></ul><p>一个动画的主要因素有</p><ul><li><code>Animation</code> 动画对象</li><li><code>AnimationController</code> 动画控制器</li><li><code>Tween</code> 动画取值范围</li><li><code>Curve</code> 动画运动曲线</li></ul><p>Flutter 动画基于类型化的 <code>Animation</code> 对象，<code>Widgets</code> 通过读取动画对象的当前值和监听状态变化重新运行 <code>build</code> 函数，不断变化 UI 形成动画效果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/flutter/flutter-animation-basics-with-implicit-animations-95db481c5916" target="_blank" rel="noopener">Flutter animation basics with implicit animations</a></p><p><a href="https://medium.com/flutter/directional-animations-with-built-in-explicit-animations-3e7c5e6fbbd7" target="_blank" rel="noopener">Directional animations with built-in explicit animations</a></p><p><a href="https://flutter.cn/docs/development/ui/animations" target="_blank" rel="noopener">动画效果介绍</a></p><p><a href="https://book.flutterchina.club/chapter9/intro.html" target="_blank" rel="noopener">Flutter动画简介</a></p><p><a href="https://flutter.cn/docs/development/ui/animations/tutorial" target="_blank" rel="noopener">在 Flutter 应用里实现动画效果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/flutter-animation-from-zero/cover.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
      <category term="Animation" scheme="https://coldstone.fun/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>在 Flutter 里使用 Stream</title>
    <link href="https://coldstone.fun/post/2020/04/13/flutter-stream/"/>
    <id>https://coldstone.fun/post/2020/04/13/flutter-stream/</id>
    <published>2020-04-13T04:07:56.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/flutter-stream/stream.png" alt="stream"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Flutter 中有两种处理异步操作的方式 <code>Future</code> 和 <code>Stream</code>，<code>Future</code> 用于处理单个异步操作，<code>Stream</code> 用来处理连续的异步操作。比如往水杯倒水，将一个水杯倒满为一个 <code>Future</code>，连续的将多个水杯倒满就是 <code>Stream</code>。</p><p><img src="./images/flutter-stream/water-fill.png" alt="water-fill"></p><h2 id="Stream-详解"><a href="#Stream-详解" class="headerlink" title="Stream 详解"></a>Stream 详解</h2><p><code>Stream</code> 是一个抽象类，用于表示一序列异步数据的源。它是一种产生连续事件的方式，可以生成数据事件或者错误事件，以及流结束时的完成事件。</p><pre><code class="dart">abstract class Stream&lt;T&gt; {  Stream();}</code></pre><p><code>Stream</code> 分单订阅流和广播流。</p><p>单订阅流在发送完成事件之前只允许设置一个监听器，并且只有在流上设置监听器后才开始产生事件，取消监听器后将停止发送事件。即使取消了第一个监听器，也不允许在单订阅流上设置其他的监听器。广播流则允许设置多个监听器，也可以在取消上一个监听器后再次添加新的监听器。</p><p><code>Stream</code> 有同步流和异步流之分。</p><p>它们的区别在于同步流会在执行 <code>add</code>，<code>addError</code> 或 <code>close</code> 方法时立即向流的监听器 <code>StreamSubscription</code> 发送事件，而异步流总是在事件队列中的代码执行完成后在发送事件。</p><h2 id="Stream-家族"><a href="#Stream-家族" class="headerlink" title="Stream 家族"></a><code>Stream</code> 家族</h2><p><code>StreamController</code></p><p>带有控制流方法的流。 可以向它的流发送数据，错误和完成事件，也可以检查数据流是否已暂停，是否有监听器。<code>sync</code> 参数决定这个流是同步流还是异步流。</p><pre><code class="dart">abstract class StreamController&lt;T&gt; implements StreamSink&lt;T&gt; {  Stream&lt;T&gt; get stream;  /// ...}StreamController _streamController = StreamController(  onCancel: () {},  onListen: () {},  onPause: () {},  onResume: () {},  sync: false,);</code></pre><p><code>StreamSink</code></p><p>流事件的入口。提供 <code>add</code>，<code>addError</code>，<code>addStream</code> 方法向流发送事件。</p><pre><code class="dart">abstract class StreamSink&lt;S&gt; implements EventSink&lt;S&gt;, StreamConsumer&lt;S&gt; {  Future close();  /// ...  Future get done;}</code></pre><p><code>StreamSubscription</code></p><p>流的监听器。提供 <code>cacenl</code>、<code>pause</code>, <code>resume</code> 等方法管理。</p><pre><code class="dart">abstract class StreamSubscription&lt;T&gt; {  /// ...}StreamSubscription subscription = StreamController().stream.listen(print);subscription.onDone(() =&gt; print(&#39;done&#39;));</code></pre><p><code>StreamBuilder</code></p><p>使用流数据渲染 UI 界面的部件。</p><pre><code class="dart">StreamBuilder(  // 数据流  stream: stream,  // 初始数据  initialData: &#39;loading...&#39;,  builder: (context, AsyncSnapshot snapshot) {    // AsyncSnapshot 对象为数据快照，缓存了当前数据和状态    // snapshot.connectionState    // snapshot.data    if (snapshot.hasData) {      Map data = snapshot.data;      return Text(data),    }    return CircularProgressIndicator();  },)</code></pre><h2 id="创建-Stream"><a href="#创建-Stream" class="headerlink" title="创建 Stream"></a>创建 Stream</h2><p>在 Dart 有几种方式创建 <code>Stream</code></p><ol><li>从现有的生成一个新的流 <code>Stream</code>，使用 <code>map</code>，<code>where</code>，<code>takeWhile</code> 等方法。</li></ol><pre><code class="dart">// 整数流Stream&lt;int&gt; intStream = StreamController&lt;int&gt;().stream;// 偶数流Stream&lt;int&gt; evenStream = intStream.where((int n) =&gt; n.isEven);// 两倍流Stream&lt;int&gt; doubleStream = intStream.map((int n) =&gt; n * 2);// 数字大于 10 的流Stream&lt;int&gt; biggerStream = intStream.takeWhile((int n) =&gt; n &gt; 10);</code></pre><ol start="2"><li>使用 <code>async*</code> 函数。</li></ol><pre><code class="dart">Stream&lt;int&gt; countStream(int to) async* {  for (int i = 1; i &lt;= to; i++) {    yield i;  }}Stream stream = countStream(10);stream.listen(print);</code></pre><ol start="3"><li>使用 <code>StreamController</code>。</li></ol><pre><code class="dart">StreamController&lt;Map&gt; _streamController = StreamController(  onCancel: () {},  onListen: () {},  onPause: () {},  onResume: () {},  sync: false,);Stream _stream = _streamController.stream;</code></pre><ol start="4"><li>使用 <code>Future</code> 对象生成</li></ol><pre><code class="dart">Future&lt;int&gt; _delay(int seconds) async {  await Future.delayed(Duration(seconds: seconds));  return seconds;}List&lt;Future&gt; futures = [];for (int i = 0; i &lt; 10; i++) {  futures.add(_delay(3));}Stream _futuresStream = Stream.fromFutures(futures);</code></pre><h2 id="应用-Stream"><a href="#应用-Stream" class="headerlink" title="应用 Stream"></a>应用 Stream</h2><p><em>Stream Counter</em></p><p>把 Flutter 的默认项目改用 <code>Stream</code> 实现</p><img src="./images/flutter-stream/stream-counter.gif" width="320" style="width:320px"><pre><code class="dart">import &#39;dart:async&#39;;import &#39;package:flutter/material.dart&#39;;class StreamCounter extends StatefulWidget {  @override  _StreamCounterState createState() =&gt; _StreamCounterState();}class _StreamCounterState extends State&lt;StreamCounter&gt; {  // 创建一个 StreamController  StreamController&lt;int&gt; _counterStreamController = StreamController&lt;int&gt;(    onCancel: () {      print(&#39;cancel&#39;);    },    onListen: () {      print(&#39;listen&#39;);    },  );  int _counter = 0;  Stream _counterStream;  StreamSink _counterSink;  // 使用 StreamSink 向 Stream 发送事件，当 _counter 大于 9 时调用 close 方法关闭流。  void _incrementCounter() {    if (_counter &gt; 9) {      _counterSink.close();      return;    }    _counter++;    _counterSink.add(_counter);  }  // 主动关闭流  void _closeStream() {    _counterStreamController.close();  }  @override  void initState() {    super.initState();    _counterSink = _counterStreamController.sink;    _counterStream = _counterStreamController.stream;  }  @override  void dispose() {    super.dispose();    _counterSink.close();    _counterStreamController.close();  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Stream Counter&#39;),      ),      body: Center(        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          children: &lt;Widget&gt;[            Text(&#39;You have pushed the button this many times:&#39;),            // 使用 StreamBuilder 显示和更新 UI            StreamBuilder&lt;int&gt;(              stream: _counterStream,              initialData: _counter,              builder: (context, snapshot) {                if (snapshot.connectionState == ConnectionState.done) {                  return Text(                    &#39;Done&#39;,                    style: Theme.of(context).textTheme.bodyText2,                  );                }                int number = snapshot.data;                return Text(                  &#39;$number&#39;,                  style: Theme.of(context).textTheme.bodyText2,                );              },            ),          ],        ),      ),      floatingActionButton: Row(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          FloatingActionButton(            onPressed: _incrementCounter,            tooltip: &#39;Increment&#39;,            child: Icon(Icons.add),          ),          SizedBox(width: 24.0),          FloatingActionButton(            onPressed: _closeStream,            tooltip: &#39;Close&#39;,            child: Icon(Icons.close),          ),        ],      ),    );  }}</code></pre><p><em>NetWork Status</em></p><p>监听手机的网络链接状态，首先添加 <code>connectivity</code> 插件</p><pre><code class="yml">dependencies:  connectivity: ^0.4.8+2</code></pre><img src="./images/flutter-stream/network-status.gif" width="320" style="width:320px"><pre><code class="dart">import &#39;dart:async&#39;;import &#39;package:connectivity/connectivity.dart&#39;;import &#39;package:flutter/material.dart&#39;;class NetWorkStatus extends StatefulWidget {  @override  _NetWorkStatusState createState() =&gt; _NetWorkStatusState();}class _NetWorkStatusState extends State&lt;NetWorkStatus&gt; {  StreamController&lt;ConnectivityResult&gt; _streamController = StreamController();  StreamSink _streamSink;  Stream _stream;  String _result;  void _checkStatus() async {    final ConnectivityResult result = await Connectivity().checkConnectivity();    if (result == ConnectivityResult.mobile) {      _result = &#39;mobile&#39;;    } else if (result == ConnectivityResult.wifi) {      _result = &#39;wifi&#39;;    } else if (result == ConnectivityResult.none) {      _result = &#39;none&#39;;    }    setState(() {});  }  @override  void initState() {    super.initState();    _stream = _streamController.stream;    _streamSink = _streamController.sink;    _checkStatus();    Connectivity().onConnectivityChanged.listen(      (ConnectivityResult result) {        _streamSink.add(result);      },    );  }  @override  dispose() {    super.dispose();    _streamSink.close();    _streamController.close();  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Network Status&#39;),      ),      body: Center(        child: StreamBuilder&lt;ConnectivityResult&gt;(          stream: _stream,          builder: (context, AsyncSnapshot snapshot) {            if (snapshot.hasData) {              if (snapshot.data == ConnectivityResult.mobile) {                _result = &#39;mobile&#39;;              } else if (snapshot.data == ConnectivityResult.wifi) {                _result = &#39;wifi&#39;;              } else if (snapshot.data == ConnectivityResult.none) {                return Text(&#39;还没有链接网络&#39;);              }            }            if (_result == null) {              return CircularProgressIndicator();            }            return ResultText(_result);          },        ),      ),    );  }}class ResultText extends StatelessWidget {  final String result;  const ResultText(this.result);  @override  Widget build(BuildContext context) {    return RichText(      text: TextSpan(        style: TextStyle(color: Colors.black),        text: &#39;正在使用&#39;,        children: [          TextSpan(            text: &#39; $result &#39;,            style: TextStyle(              color: Colors.red,              fontSize: 20.0,              fontWeight: FontWeight.bold,            ),          ),          TextSpan(text: &#39;链接网络&#39;),        ],      ),    );  }}</code></pre><p><code>Random Article</code></p><p>请求网络数据创建流</p><pre><code class="yml">dependencies:  dio: ^3.0.9  flutter_html: ^0.11.1</code></pre><img src="./images/flutter-stream/random-article.gif" width="320" style="width:320px"><pre><code class="dart">import &#39;dart:async&#39;;import &#39;package:dio/dio.dart&#39;;import &#39;package:flutter/material.dart&#39;;import &#39;package:flutter_html/flutter_html.dart&#39;;class RandomArticle extends StatefulWidget {  @override  _RandomArticleState createState() =&gt; _RandomArticleState();}class _RandomArticleState extends State&lt;RandomArticle&gt; {  static Dio _dio = Dio(    BaseOptions(baseUrl: &#39;https://interface.meiriyiwen.com&#39;),  );  static Future&lt;Map&gt; _getArticle() async {    Response response = await _dio.get(      &#39;/article/random&#39;,      queryParameters: {&quot;dev&quot;: 1},    );    final data = response.data[&#39;data&#39;];    return data;  }  Stream&lt;Map&gt; _futuresStream;  @override  void initState() {    List&lt;Future&lt;Map&gt;&gt; futures = [];    for (int i = 0; i &lt; 10; i++) {      // 添加 Future      futures.add(_getArticle());    }    // 生成 Stream    _futuresStream = Stream&lt;Map&gt;.fromFutures(futures);    super.initState();  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;Random Article&#39;)),      body: SingleChildScrollView(        child: Center(          child: StreamBuilder&lt;Map&gt;(            stream: _futuresStream,            builder: (context, AsyncSnapshot snapshot) {              if (snapshot.hasData) {                Map article = snapshot.data;                return Container(                  child: Column(                    children: &lt;Widget&gt;[                      SizedBox(height: 24.0),                      Text(                        article[&#39;title&#39;],                        style: TextStyle(fontSize: 24.0),                      ),                      Padding(                        padding: const EdgeInsets.only(                          top: 12.0,                          left: 12.0,                          right: 12.0,                          bottom: 60.0,                        ),                        child: Html(                          data: article[&#39;content&#39;],                        ),                      ),                    ],                  ),                );              }              return CircularProgressIndicator();            },          ),        ),      ),    );  }}</code></pre><p><code>Broadcast Stream</code></p><p>使用广播流</p><img src="./images/flutter-stream/broadcast-stream.gif" width="320" style="width:320px"><pre><code class="dart">import &#39;dart:async&#39;;import &#39;package:flutter/material.dart&#39;;class BroadcastStream extends StatefulWidget {  @override  _BroadcastStreamState createState() =&gt; _BroadcastStreamState();}class _BroadcastStreamState extends State&lt;BroadcastStream&gt; {  StreamController&lt;int&gt; _streamController = StreamController&lt;int&gt;.broadcast();  StreamSubscription _subscription1;  StreamSubscription _subscription2;  StreamSubscription _subscription3;  int _count = 0;  int _s1 = 0;  int _s2 = 0;  int _s3 = 0;  @override  void initState() {    _subscription1 = _streamController.stream.listen((n) {      setState(() {        _s1 += 1;      });    });    _subscription2 = _streamController.stream.listen((n) {      setState(() {        _s2 += 2;      });    });    _subscription3 = _streamController.stream.listen((n) {      setState(() {        _s3 -= 1;      });    });    super.initState();  }  void _add() {    if (_count &gt; 10) {      // 大于 10 时停止第一个订阅      _subscription1.cancel();    }    _count++;    _streamController.add(_count);  }  @override  void dispose() {    super.dispose();    _streamController.close();    _subscription1.cancel();    _subscription2.cancel();    _subscription3.cancel();  }  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Broadcast Stream&#39;),      ),      body: Container(        width: double.infinity,        height: MediaQuery.of(context).size.height,        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          crossAxisAlignment: CrossAxisAlignment.center,          children: [            Text(&#39;Count: $_count&#39;),            SizedBox(height: 12.0),            Text(&#39;S1: $_s1&#39;),            SizedBox(height: 12.0),            Text(&#39;S2: $_s2&#39;),            SizedBox(height: 12.0),            Text(&#39;S3: $_s3&#39;),            SizedBox(height: 12.0),            FloatingActionButton(              onPressed: _add,              child: Icon(Icons.plus_one),            ),          ],        ),      ),    );  }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Stream</code> 是处理异步编程的方式之一，它提供一个了异步的事件序列，并在你准备好接受时发送。在 Dart 中流分为同步流和异步流，以及单订阅流和广播流，有多种方式创建 <code>Stream</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dart.cn/tutorials/language/streams" target="_blank" rel="noopener">异步编程：使用 stream</a></p><p><a href="https://dart.cn/articles/libraries/creating-streams" target="_blank" rel="noopener">在 Dart 里使用 Stream</a></p><p><a href="https://guoshuyu.cn/home/wx/Flutter-11.html" target="_blank" rel="noopener">全面深入理解Stream</a></p><p><a href="https://codingwithjoe.com/flutter-building-a-widget-with-streambuilder/" target="_blank" rel="noopener">Building a Widget with StreamBuilder</a></p><p><a href="https://youtu.be/MkKEWHfy99Y" target="_blank" rel="noopener">StreamBuilder (Flutter 本周小部件)</a></p><p><a href="https://youtu.be/nQBpOIHE4eE" target="_blank" rel="noopener">Dart Streams - 聚焦 Flutter</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/flutter-stream/stream.png&quot; alt=&quot;stream&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 是如何渲染的？</title>
    <link href="https://coldstone.fun/post/2020/04/03/how-flutter-render/"/>
    <id>https://coldstone.fun/post/2020/04/03/how-flutter-render/</id>
    <published>2020-04-03T04:40:04.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/how-flutter-render/cover.jpg" alt="cover"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Flutter 开发移动端有一段时间了，总结一下关于 UI 渲染方面的知识。了解关于 Flutter 渲染方面的知识还是有必要的，可以帮助你开发更稳定，性能更高的应用。</p><p>要解答这个问题，首先需要认识到 Flutter 中有三棵树：<code>Widget</code> 树，<code>Element</code> 树和 <code>RenderObject</code> 树。</p><p>当应用启动时 Flutter 会遍历并创建所有的 <code>Widget</code> 形成 <code>Widget Tree</code>，同时与 <code>Widget Tree</code> 相对应，通过调用 <code>Widget</code> 上的 <code>createElement()</code> 方法创建每个 <code>Element</code> 对象，形成 <code>Element Tree</code>。</p><p>最后调用 <code>Element</code> 的 <code>createRenderObject()</code> 方法创建每个渲染对象，形成一个 <code>Render Tree</code>。</p><p>然后需要知道 <code>Widget</code>，<code>Element</code> 和 <code>RenderObject</code> 到底是啥以及它们是干什么的。</p><h2 id="什么是-Widget"><a href="#什么是-Widget" class="headerlink" title="什么是 Widget"></a>什么是 Widget</h2><p><code>Widget</code> 是 Flutter 的核心部分，是用户界面的不可变描述信息。正如 Flutter 的口号 <code>Everything’s a widget</code>, 用 Flutter 开发应用就是在写 <code>Widget</code> 🐶。</p><p>Flutter 的 <code>Widget</code> 不只表示 UI 控件，还表示一些功能性的组件，如路由跳转 <code>Navigator</code>，手势检测 <code>GestureDetector</code> 组件等。</p><pre><code class="dart">@immutableabstract class Widget extends DiagnosticableTree {  /// Initializes [key] for subclasses.  const Widget({ this.key });  final Key key;  /// ...  @protected  Element createElement();  /// ...  static bool canUpdate(Widget oldWidget, Widget newWidget) {    return oldWidget.runtimeType == newWidget.runtimeType      &amp;&amp; oldWidget.key == newWidget.key;  }}</code></pre><p><code>Widget</code> 的 <code>canUpdate</code> 方法通过比较新部件和旧部件的 <code>runtimeType</code> 和 <code>key</code> 属性是否相同来决定更新部件对应的 <code>Element</code>。</p><h2 id="什么是-Element"><a href="#什么是-Element" class="headerlink" title="什么是 Element"></a>什么是 Element</h2><p><code>Element</code> 是实例化的 <code>Widget</code> 对象，通过 <code>Widget</code> 的 <code>createElement()</code> 方法，在特定位置使用 <code>Widget</code> 配置数据生成。</p><p><code>Element</code> 用于管理应用 UI 的更新和更改，管理部件的生命周期，每个 <code>Element</code> 都包含对 <code>Widget</code> 和 <code>RenderObject</code> 的引用。</p><p><img src="./images/how-flutter-render/relationship.png" alt="relationship"></p><p>当 <code>Widget</code> 变化时，如果两个 <code>Widget</code> 的 <code>runtimeType</code> 和 <code>key</code> 属性相同的，那么新的 <code>Element</code> 会通过 <code>Element.update()</code> 更新旧的 <code>Element</code>，否则旧的 <code>Element</code> 会被删除，新生成的 <code>Element</code> 插入到树中。</p><pre><code class="dart">abstract class Element extends DiagnosticableTree implements BuildContext {  /// Creates an element that uses the given widget as its configuration.  ///  /// Typically called by an override of [Widget.createElement].  Element(Widget widget)    : assert(widget != null),      _widget = widget;  /// Change the widget used to configure this element.  ///  /// The framework calls this function when the parent wishes to use a  /// different widget to configure this element. The new widget is guaranteed  /// to have the same [runtimeType] as the old widget.  ///  /// This function is called only during the &quot;active&quot; lifecycle state.  @mustCallSuper  void update(covariant Widget newWidget) {    /// ...  }  /// Creates an instance of the [RenderObject] class that this  /// [RenderObjectWidget] represents, using the configuration described by this  /// [RenderObjectWidget].  ///  /// This method should not do anything with the children of the render object.  /// That should instead be handled by the method that overrides  /// [RenderObjectElement.mount] in the object rendered by this object&#39;s  /// [createElement] method. See, for example,  /// [SingleChildRenderObjectElement.mount].  @protected  RenderObject createRenderObject(BuildContext context);}</code></pre><h2 id="什么是-RenderObject"><a href="#什么是-RenderObject" class="headerlink" title="什么是 RenderObject"></a>什么是 RenderObject</h2><p><code>RenderObject</code> 用于应用界面的布局和绘制，保存了元素的大小，布局等信息，实例化一个 <code>RenderObject</code> 是非常耗能的。</p><p>当应用运行时 Flutter 使用 <code>RenderObject</code> 的数据绘制应用界面，最终形成一个 <code>Render Tree</code>。</p><pre><code class="dart">abstract class RenderObject extends AbstractNode with DiagnosticableTreeMixin implements HitTestTarget {  /// Initializes internal fields for subclasses.  RenderObject() {    _needsCompositing = isRepaintBoundary || alwaysNeedsCompositing;  }  /// The render object at (or below) this location in the tree.  ///  /// If this object is a [RenderObjectElement], the render object is the one at  /// this location in the tree. Otherwise, this getter will walk down the tree  /// until it finds a [RenderObjectElement].  RenderObject get renderObject {    RenderObject result;    void visit(Element element) {      assert(result == null); // this verifies that there&#39;s only one child      if (element is RenderObjectElement)        result = element.renderObject;      else        element.visitChildren(visit);    }    visit(this);    return result;  }  void layout(Constraints constraints, { bool parentUsesSize = false }) {    /// ...  }  /// ...  void paint(PaintingContext context, Offset offset) {    /// ...  }}</code></pre><h2 id="为什么需要三棵树"><a href="#为什么需要三棵树" class="headerlink" title="为什么需要三棵树"></a>为什么需要三棵树</h2><p>使用三棵树的目的是尽可能复用 <code>Element</code>。</p><p>复用 <code>Element</code> 对性能非常重要，因为 <code>Element</code> 拥有两份关键数据：<code>Stateful widget</code> 的状态对象及底层的<br><code>RenderObject</code>。</p><p>当应用的结构很简单时，或许体现不出这种优势，一旦应用复杂起来，构成页面的元素越来越多，重新创建 3 棵树的代价是很高的，所以需要最小化更新操作。</p><p>当 Flutter 能够复用 <code>Element</code> 时，用户界面的逻辑状态信息是不变的，并且可以重用之前计算的布局信息，避免遍历整棵树。</p><h2 id="举个例子说明"><a href="#举个例子说明" class="headerlink" title="举个例子说明"></a>举个例子说明</h2><p>创建一个简单的 Flutter 应用，代码如下</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;void main() {  runApp(    MaterialApp(      color: Colors.white,      debugShowCheckedModeBanner: false,      builder: (context, child) =&gt; HomePage(),    ),  );}class HomePage extends StatefulWidget {  @override  _HomePageState createState() =&gt; _HomePageState();}class _HomePageState extends State&lt;HomePage&gt; {  bool _isWorld = true;  Widget _buildWorld() {    return RichText(      text: TextSpan(        text: &#39;Hello world&#39;,        style: TextStyle(color: Colors.black),      ),    );  }  Widget _buildFlutter() {    return RichText(      text: TextSpan(        text: &#39;Hello flutter&#39;,        style: TextStyle(color: Colors.black),      ),    );  }  void changeText() {    setState(() {      _isWorld = !_isWorld;    });  }  @override  Widget build(BuildContext context) {    return Scaffold(      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          Center(            child: _isWorld ? _buildWorld() : _buildFlutter(),          ),          SizedBox(height: 20.0),          // Padding(padding: EdgeInsets.only(top: 20.0)),          IconButton(icon: Icon(Icons.refresh), onPressed: changeText)        ],      ),    );  }}</code></pre><p>显示效果</p><img src="./images/how-flutter-render/simulator-world.png" style="width:320px"><p>打开 <a href="http://127.0.0.1:9100" target="_blank" rel="noopener">Dart DevTools</a>，可以看到应用的 <code>Widget Tree</code>，此时 <code>RichText</code> 控件的 <code>RenderObject</code> 的 ID 是 <code>#6276a</code></p><p><img src="./images/how-flutter-render/world-id.png" alt="world-id"></p><p>点击图标将文字变成 <code>Hello flutter</code> 时</p><img src="./images/how-flutter-render/simulator-flutter.png" style="width:320px"><p>刷新浏览器页面再次查看 <code>RichText</code> 的 <code>RenderObject</code> 的 ID 依然是 <code>#6276a</code></p><p><img src="./images/how-flutter-render/flutter-id.png" alt="flutter-id"></p><p>可以发现 Flutter 只是更新了文字数据，复用了 <code>RichText</code> 对应的 <code>Element</code> 和 <code>RenderObject</code>。</p><p>而使用 <code>SizedBox</code> 部件取代 <code>Padding</code> 部件时。</p><pre><code class="dart">@overrideWidget build(BuildContext context) {  return Scaffold(    body: Column(      mainAxisAlignment: MainAxisAlignment.center,      children: &lt;Widget&gt;[        Center(          child: RichText(            text: TextSpan(              text: &#39;Hello $text&#39;,              style: TextStyle(color: Colors.black),            ),          ),        ),        SizedBox(height: 20.0),        // Padding(padding: EdgeInsets.only(top: 20.0)),        IconButton(icon: Icon(Icons.refresh), onPressed: changeText)      ],    ),  );}</code></pre><p><img src="./images/how-flutter-render/padding.png" alt="padding"></p><p><code>Padding</code> 部件对应的 <code>Element</code> 和 <code>RenderObject</code> 都会被从树中移除，使用 <code>SizedBox</code> 新生成的替代。</p><p><img src="./images/how-flutter-render/sizeedbox.png" alt="sizeedbox"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Widget</code> 是应用界面的声明信息。<br><code>Element</code> 链接 <code>Widget</code> 和 <code>RenderObject</code>，管理界面的更新和修改。<br><code>RenderObject</code> 保存具体的布局信息，负责绘制 UI。</p><p><img src="./images/how-flutter-render/widget-element-render-object.png" alt="widget-element-render-object"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://youtu.be/996ZgFRENMs" target="_blank" rel="noopener">How Flutter renders Widgets</a> (Video)</p><p><a href="https://medium.com/manabie/how-flutter-renders-widgets-fd6eca945a04" target="_blank" rel="noopener">How Flutter renders Widgets</a></p><p><a href="https://book.flutterchina.club/chapter14/flutter_ui_system.html" target="_blank" rel="noopener">Flutter UI系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/how-flutter-render/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>PlantUML 类图及 Flowchart 流程图绘制入门</title>
    <link href="https://coldstone.fun/post/2020/03/26/learn-classchart-flowchart/"/>
    <id>https://coldstone.fun/post/2020/03/26/learn-classchart-flowchart/</id>
    <published>2020-03-26T02:00:00.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/draw.jpg" alt="draw"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间设计后端表结构的时候接触了 <code>PlantUML</code>，它能够直观表现出类的属性和方法，反应出类与类之间的关系。之前有同事就是用 <code>PlantUML</code> 来做后端数据表设计工作的，所以有必要学习一下。</p><p>流程图 <code>Flowchart</code> 是用来展示操作过程或逻辑流程的一种图表，语法比较简单，方便易用，一些比较复杂的判断都可以使用一个流程图来直观表现。</p><h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><p><a href="https://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a> 是一个开源项目，支持快速绘制时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图等。同时还支持非 UML 图的甘特图、架构图等。</p><p><code>PlantUML</code> 有一些通用语法</p><ul><li>单行注释：以单引号 <code>&#39;</code> 开头的语句。</li><li>多行注释：以 <code>/&#39;</code> 和 <code>&#39;/</code> 作为注释的开始和结束。</li><li>页眉：使用 <code>header</code> 命令在生成的图中增加页眉，用 <code>center</code>, <code>left</code> 或 <code>right</code> 实现居中、左对齐和右对齐。</li><li>页脚：使用 <code>footer</code> 命令在生成的图中增加页眉，用 <code>center</code>, <code>left</code> 或 <code>right</code> 实现居中、左对齐和右对齐。</li><li>缩放：使用 <code>scale</code> 命令缩放生成的图像。</li><li>标题：使用 <code>title</code> 关键字添加标题。</li><li>图片标题：使用 <code>caption</code> 关键字在图像下放置一个标题.</li><li>图例说明: <code>legend</code> 和 <code>endlegend</code> 作为关键词，使用 <code>left</code>, <code>right</code>, <code>center</code> 为这个图例指定对齐方式。</li></ul><p>一个🌰 <a href="http://www.plantuml.com/plantuml/uml/FO_D2i8m48JlynHxAmZI8eBYGIhU12_Y2uHsRHVo8ytMvtVHj8V0DxERcQJDwYQTWqVkd6Swx9hD_jW0rOMonC4iBv6fIo5mLA2kGFGS9PDae_liLRomuRMiL3M0peWd6jdrFA7iBv9ZNmWgQXNB_AViidkhfBZQHGEF53ZHzaotsJgLJkJJXwtEys2XQu-ZOjWfX5TAzg8ryo_Hsin-_mK0" target="_blank" rel="noopener">查看</a></p><pre><code class="uml">@startumlscale 720*480&#39;A single line comment/&#39;  This is  Multilie  Comment&#39;/center headerThis is headerendheadertitle This is titlecaption This is captionRomeo -&gt; Juliet : lovelegendThis is a legendendlegendfooter This is footer@enduml</code></pre><img style="width:320px" alt="base" src="http://www.plantuml.com/plantuml/png/HP3D2i8m48JlynHxAmZI8eBYGIhU12_Y2uHsRHVo8ytMvtUnFrwIRoQp6TWwgnjq31wvSPxfiAis-sC551VA4Zkpl4Ic9eN0KO6o0D6pbqoIZUwZL_72XjSvKfG06YCUg6VNseLvODKSsma15RMI9V1JDkxUAYckzgo1HmgSQ7kcssYjIYVowSC0F7VswR_9qUBOCI7mIacjVibC4hMzsGQ-"><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>画类图需要了解类与类之间的几种不同的关系</p><table><thead><tr><th align="left">关系</th><th align="left">意思</th><th align="left">标记</th></tr></thead><tbody><tr><td align="left">Association 关系</td><td align="left">两个类之间有相互关系</td><td align="left"><code>&lt;--</code></td></tr><tr><td align="left">Inheritance 继承</td><td align="left">子类继承父类</td><td align="left"><code>&lt;|--</code></td></tr><tr><td align="left">Composition 组合</td><td align="left">两个类之间相互依赖</td><td align="left"><code>*--</code></td></tr><tr><td align="left">Aggregation 聚合</td><td align="left">一个类属于另一个类</td><td align="left"><code>o--</code></td></tr><tr><td align="left">Implementation 实现</td><td align="left">一个类实现另一个类的方法</td><td align="left"><code>&lt;|..</code></td></tr><tr><td align="left">Dependency 依赖</td><td align="left">一个类依赖于另一个类</td><td align="left"><code>&lt;..</code></td></tr></tbody></table><p><img src="https://miro.medium.com/max/1180/1*EUvDMA1vr0DiucONPzK9kA.png" alt="关系图"></p><p>设计一个博客系统😜 <a href="http://www.plantuml.com/plantuml/umla/XPBHwjCm58VlynJdSdDs3lL2YiZ4Hn2zh-t11TeKaenTw63Wc5CSSwB3JS4v54MXkn2nEFLfbgQ-XUiQszaXV-X5slFzlfoSj2samsKty8bm7H_XyfNMkKiNMyH59f531nqFETd5WrtyIKS3DNcXbqCrMQfehRzizVODGUOPYX3NTuI0srHG6NAuH-0E3ti2QtNIBwhNkQIkZrcr0TIpWJAPBPskx8IyU7L39f596uJabDqz4jmIU713mwIp9NC2jE5cpWBi7mjwd4eqszKgllg1SCCWG2R_o_IBfhs0icnJ2ppqiTIQ5kfbvKRk_AU27fMLnFdoXCTK9LsXeEp8W2U3g9mX-tGqsIn_cD_L-vPbJcK3wEYjVZfIivV9wqTglFgzU7T1_vYdlsR9_A7-l5BFdgIROHfztzzz-k2dUlpAI9hDuZfjqCy_9kDlQhhPRT-hqIAFbg1f-1JCrUIloBAk5N-G3KaSgsYTiydNQVfXRBn6ToPkx6raNZVm_m00" target="_blank" rel="noopener">点击查看</a></p><pre><code class="uml">@startumlcenter header一个简单的博客系统endheaderclass Visitor { browse()}class Article { + id: int + author: int + content: string}class User {  +id: int  +name: String  - writeArticle(content: string)  - commentArticle(content: string)}class Admin { - deleteArticle(id: int) - deleteComment(id: int) - editArticle(id: int, content: int) - editComment(id: int, content: int)}class Comment {  +id: int  +content: string  +author: int}User &lt;|-- Admin : 管理员有删除/编辑文章和评论的能力User &lt;.. Article : 用户可以写文章User &lt;.. Comment : 用户可以写评论Article --&gt; Visitor : 游客可以浏览文章Comment --&gt; Visitor : 游客可以浏览评论@enduml</code></pre><p><img src="./images/learn-chart/class.png" alt="blog"></p><h2 id="Flowchart"><a href="#Flowchart" class="headerlink" title="Flowchart"></a>Flowchart</h2><p>流程图使用 <a href="http://flowchart.js.org/" target="_blank" rel="noopener">Flowchart</a> 绘制，语法比较简单。</p><p>定义一个流程图元素 <code>name=&gt;type: content:&gt;url</code></p><ul><li>name: 元素的名称</li><li>type：类型，包括如下类别：<ul><li>start</li><li>end</li><li>operation</li><li>subroutine</li><li>condition</li><li>inputoutput</li><li>parallel</li></ul></li><li>content：文本内容</li><li>url：连接</li></ul><p>示例如下</p><pre><code class="ts">st=&gt;start: 艰难的开始ge=&gt;end: 你成功了:&gt;https://www.zhihu.com/hotbe=&gt;end: 你失败了:&gt;https://bbs.hupu.com/bxjskill=&gt;condition: 有技能吗money=&gt;condition: 有钱吗handsome=&gt;condition: 长得帅吗dream=&gt;operation: 做梦imp=&gt;operation: 努力提高自己work=&gt;operation: 工作/读书make=&gt;operation: 投资理财rich=&gt;operation: 找富婆st-&gt;skillskill(yes)-&gt;work-&gt;geskill(no)-&gt;moneymoney(yes)-&gt;make-&gt;gemoney(no)-&gt;handsomehandsome(yes)-&gt;rich-&gt;gehandsome(no)-&gt;be</code></pre><p><img src="./images/learn-chart/flow.png" alt="start"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a></p><p><a href="https://github.com/adrai/flowchart.js" target="_blank" rel="noopener">Flowchart</a></p><p><a href="https://medium.com/@smagid_allThings/uml-class-diagrams-tutorial-step-by-step-520fd83b300b" target="_blank" rel="noopener">UML Class Diagrams Tutorial, Step by Step</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/draw.jpg&quot; alt=&quot;draw&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://coldstone.fun/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="PlantUML" scheme="https://coldstone.fun/tags/PlantUML/"/>
    
      <category term="Flowchart" scheme="https://coldstone.fun/tags/Flowchart/"/>
    
  </entry>
  
  <entry>
    <title>记录两个使用 Flutter 的 DropdownButton 问题</title>
    <link href="https://coldstone.fun/post/2020/03/24/flutter-dropdown-problem/"/>
    <id>https://coldstone.fun/post/2020/03/24/flutter-dropdown-problem/</id>
    <published>2020-03-24T08:08:27.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在使用 <code>Flutter</code> 开发应用过程中遇到关于 <code>DropdownButton</code> 两个问题，记录一下。</p><p>问题一：在 <code>showModalBottomSheet</code> 里面使用 <code>DropdownButton</code> 改变选择后界面不变化。</p><p><img src="./images/flutter-dropdown-problem/dropdown-no-change.gif" alt="no-change"></p><p>但是 <code>onChanged</code> 事件已经触发</p><p><img src="./images/flutter-dropdown-problem/console.png" alt="console"></p><p>代码如下</p><pre><code class="dart">int _type = 0;...IconButton(  icon: Icon(Icons.filter_list),  onPressed: () {    showModalBottomSheet(      context: context,      builder: (BuildContext context) {        return Column(          crossAxisAlignment: CrossAxisAlignment.start,          children: &lt;Widget&gt;[            Padding(              padding: const EdgeInsets.all(12.0),              child: Row(                children: &lt;Widget&gt;[                  SizedBox(                    width: 80.0,                    child: Text(&#39;类型: &#39;),                  ),                  DropdownButton&lt;int&gt;(                    value: _type,                    onChanged: (int newValue) {                      setState(() {                        _type = newValue;                      });                      print(newValue.toString());                    },                    items: [                      DropdownMenuItem&lt;int&gt;(                        value: 0,                        child: Text(&#39;类型 1&#39;),                      ),                      DropdownMenuItem&lt;int&gt;(                        value: 1,                        child: Text(&#39;类型 2&#39;),                      ),                    ],                  ),                ],              ),            ),          ],        );      },    );  },),</code></pre><p>解决方法：添加一个 <code>StatefulBuilder</code> 部件在最外层即可</p><pre><code class="dart">showModalBottomSheet(  context: context,  builder: (BuildContext context) {    return StatefulBuilder(      builder: (context, StateSetter setState) {        return Column(          crossAxisAlignment: CrossAxisAlignment.start,          children: &lt;Widget&gt;[            Padding(              padding: const EdgeInsets.all(12.0),              child: Row(                children: &lt;Widget&gt;[                  SizedBox(                    width: 80.0,                    child: Text(&#39;类型: &#39;),                  ),                  DropdownButton&lt;int&gt;(                    value: _type,                    onChanged: (int newValue) {                      setState(() {                        _type = newValue;                      });                      print(newValue.toString());                    },                    items: [                      DropdownMenuItem&lt;int&gt;(                        value: 0,                        child: Text(&#39;类型 1&#39;),                      ),                      DropdownMenuItem&lt;int&gt;(                        value: 1,                        child: Text(&#39;类型 2&#39;),                      ),                    ],                  ),                ],              ),            ),          ],        );      },    );  },);</code></pre><p>问题二：当多个 <code>DropdownMenuItem</code> 值相同时会报错</p><p><img src="./images/flutter-dropdown-problem/crash.png" alt="crash"></p><p>这个报错产生的原因是这里的 <code>DropdownMenuItem</code> 是请求后端接口后会生成很多选项，如果设置了 <code>DropdownButton</code> 的 <code>value</code> 值，那么 <code>DropdownMenuItem</code> 就会有相同的值，出现这个错误。</p><p>解决方法：不设置 <code>DropdownButton</code> 的初始 <code>value</code> 值</p><pre><code class="dart">DropdownButton&lt;int&gt;(  // value: 0,  onChanged: (int newValue) {    setState(() {});  },  items: types.map(    (item) {      return DropdownMenuItem&lt;int&gt;(        value: item[&quot;value&quot;],        child: Text(item[&quot;label&quot;]),      );    },  ).toList(),);</code></pre><p>ps：这两个问题卡了我两天😔</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这几天在使用 &lt;code&gt;Flutter&lt;/code&gt; 开发应用过程中遇到关于 &lt;code&gt;DropdownButton&lt;/code&gt; 两个问题，记录一下。&lt;/p&gt;&lt;p&gt;问题一：在 &lt;code&gt;showModalBottomSheet&lt;/code&gt; 里面使用
        
      
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之二叉树</title>
    <link href="https://coldstone.fun/post/2020/03/15/das-tree/"/>
    <id>https://coldstone.fun/post/2020/03/15/das-tree/</id>
    <published>2020-03-15T03:05:00.000Z</published>
    <updated>2020-06-18T09:46:58.872Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树是一种非线性的数据结构，以分层的方式存储数据。在二叉树上进行添加，查找和删除数据非常快。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>二叉树是一种非线性的数据结构，以分层的方式存储数据。用于存储有层级关系的数据，如计算机文件，公司组织结构等数据。在二叉树上进行添加，查找和删除数据非常快。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要实现树结构首先需要 <code>Node</code> 节点类，节点保存数据和它左右节点的链接，<code>show</code> 方法返回节点数据。</p><pre><code class="ts">class Node {  data: number  left: Node = null  right: Node = null  constructor(data: number) {    this.data = data  }  show() {    return this.data  }}</code></pre><p>实现二叉树，首先需要向树中插入节点的方法，这个方法先创建一个节点，判断树是否有根节点，没有的话将新节点作为树的根节点，否则进行下一步；</p><ol><li>设当前节点为树的根节点，开始循环</li><li>如果插入节点的数据小于当前节点的数据，将新当前节点设为原当前节点的左节点，否则执行第 4 步</li><li>如果当前节点的左节点为 <code>null</code> ，就将新的节点插入这个位置，退出循环；否则执行下一次循环</li><li>将新当前节点设为原当前节点的右节点</li><li>如果当前节点的右节点为 <code>null</code> ，就将新的节点插入这个位置，退出循环；否则执行下一次循环</li></ol><pre><code class="ts">class BST {  root: Node = null  length: number = 0  // 插入节点  insert(data: number) {    // 先创建新的节点    const node = new Node(data)    if (this.root === null) {      this.root = node      return;    } else {      let originNode      // 将当前节点设为树根节点      let currentNode = this.root      // 开始循环      while (true) {        // 保存原节点引用        originNode = currentNode        //  如果插入节点的数据小于当前节点的数据        if (data &lt; currentNode.data) {          // 将新当前节点设为原当前节点的左节点          currentNode = currentNode.left          // 如果当前节点的左节点为 `null` ，就将新的节点插入这个位置，退出循环；否则执行下一次循环          if (currentNode === null) {            originNode.left = node            break          }        } else {          // 将新当前节点设为原当前节点的右节点          currentNode = currentNode.right          // 如果当前节点的右节点为 `null` ，就将新的节点插入这个位置，退出循环；否则执行下一次循环          if (currentNode === null) {            originNode.right = node            break          }        }      }    }  }}</code></pre><p>遍历二叉树，中序，先序，后序</p><pre><code class="ts"> // 中序遍历inOrder(node: Node) {  if (node !== null) {    this.inOrder(node.left)    node.show()    this.inOrder(node.right)  }}// 先序遍历preOrder(node: Node) {  if (node !== null) {    node.show()    this.preOrder(node.left)    this.preOrder(node.right)  }}// 后序遍历postOrder(node: Node) {  if (node !== null) {    this.postOrder(node.left)    this.postOrder(node.right)    node.show()  }}</code></pre><p>查找节点</p><pre><code class="js">find(data: number): Node {  let currentNode = this.root  while (currentNode !== null) {    if (currentNode.data === data) {      return currentNode    } else if (currentNode.data &gt; data) {      currentNode = currentNode.left    } else {      currentNode = currentNode.right    }  }  return null}</code></pre><p>删除节点</p><pre><code class="ts">  remove(data: number) {    this.root = this.removeNode(this.root, data)  }  removeNode(node: Node, data: number): Node {    if (node === null) {      return null    }    if (data === node.data) {      // 没有子节点      if (node.left === null &amp;&amp; node.right === null) {        return null      }      // 没有左子节点      if (node.left === null) {        return node.right      }      // 没有右子节点      if (node.right === null) {        return node.left      }      // 有左右两个节点      const tempNode = this.min(node.right)      node.data = tempNode.data      node.right = this.removeNode(node.right, tempNode.data)      return node    } else if (node.data &gt; data) {      node.left = this.removeNode(node.left, data)      return node    } else {      node.right = this.removeNode(node.right, data)      return node    }  }</code></pre><p>最大值，最小值</p><pre><code class="ts">// 最小值节点min(node: Node = this.root): Node {  let currentNode = node  while (currentNode.left !== null) {    currentNode = currentNode.left  }  return currentNode}// 最大值节点max(node: Node = this.root): Node {  let currentNode = node  while (currentNode.right !== null) {    currentNode = currentNode.right  }  return currentNode}</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><code>BST</code> 可以用来记录一组数据中数据出现的次数，首先在 <code>Node</code> 类上添加 <code>count</code> 属性</p><pre><code class="ts">class Node {  data: number  left: Node = null  right: Node = null  count: number = 0  constructor(data: number) {    this.data = data  }  show() {    return this.data  }}</code></pre><p>在 <code>BST</code> 类上添加 <code>update</code> 方法，当插入数据为新值时使用 <code>insert</code> 方法，当插入已经存在的值时使用 <code>update</code> 方法</p><pre><code class="ts">update(data: number): Node {  const node = this.find(data)  if(node !== null) {    node.count++    console.log(`${node.data}: `, node.count)    return node  }}</code></pre><p>测试一下</p><pre><code class="ts">const bst = new BST();const array = [2, 3, 5, 6, 10, 3, 4, 2, 8, 5, 9, 1, 4, 2, 5]for (let index = 0; index &lt; array.length; index++) {    const num = array[index]    if (bst.find(num) !== null) {        bst.update(num);    }    else {        bst.insert(num);    }}// 3:  1// 2:  1// 5:  1// 4:  1// 2:  2// 5:  2</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树是一种非线性的数据结构，以分层的方式存储数据。在二叉树上进行添加，查找和删除数据非常快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Gitlib 持续发布 Flutter 应用</title>
    <link href="https://coldstone.fun/post/2020/02/27/flutter-gitlab-pineline/"/>
    <id>https://coldstone.fun/post/2020/02/27/flutter-gitlab-pineline/</id>
    <published>2020-02-27T03:01:00.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/samuel-chenard.jpg" alt="action"></p><p>本文介绍如何使用 Gitlib CI/CD 构建发布 Flutter 应用</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://coldstone.fun/post/2020/02/26/flutter-github-actions/">前一篇文章</a>介绍了使用 Github Actions 持续发布 Flutter 应用，本文分享下如何使用 Gitlib 的 CI/CD 功能同样实现发布 Flutter 应用，因为有很多公司是用自己搭建的 Gitlab 来管理代码的。</p><p>要使用 Gitlib 的 CI/CD 功能首先需要在项目根目录创建一个 yml 格式的配置文件 <code>.gitlab-ci.yml</code>，这个配置文件会定义一个流水线 Pipeline。一个 Pipeline 由多个任务 Job 组成，任务就是具体要做的事情，如代码编译或测试； Pipeline 里的 stages 决定了任务何时以及如何运行。以下就是一个 Pipeline 有 3 个 stage，依次执行 build，test 和 deploy 任务。</p><pre><code class="yml">stages:  - build  - test  - deployjob01:  stage: build  script: echo &#39;build job&#39;job02:  stage: build  script: echo &#39;test job&#39;job03:  stage: deploy  script: echo &#39;deploy job&#39;</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>要在 Pipeline 里构建打包 Flutter 应用的 apk，首先需要在流水线里配置 Android 以及 Flutter 环境，搜索一番后发现了一个 Github 上的 Flutter 镜像 <a href="https://github.com/cirruslabs/docker-images-flutter" target="_blank" rel="noopener">docker-images-flutter</a> 很适合，看这个镜像的 <a href="https://github.com/cirruslabs/docker-images-flutter/blob/master/sdk/Dockerfile" target="_blank" rel="noopener">Dockerfile</a> 可以发现它是从 <code>cirrusci/android-sdk:29</code> 这个 Android sdk 镜像开始，然后下载 Flutter SDK，这样就有了了 Android 和 Flutter 环境，接下来只需要运行测试和打包命令即可</p><pre><code class="yaml">stages:  - build  - release// build 阶段使用拥有 Android 以及 Flutter 环境的镜像，进行测试打包build:  stage: build  image: cirrusci/flutter:stable  only:    - tags  script:    // 下载依赖包    - flutter packages get    // 执行测试    - flutter test    // 打包 apk    - flutter build apk --release  // 这里定义任务生成的文件  artifacts:    expire_in: 1 hour    paths:      - build/app/outputs/apk/release/*.apk  interruptible: true</code></pre><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>要发布 apk 文件到仓库的 release 还需要使用 <a href="https://github.com/inetprocess/gitlab-release" target="_blank" rel="noopener">gitlab-release</a> 这个镜像进行发布操作</p><pre><code class="yml">stages:  - build  - release// build 阶段使用拥有 Android 以及 Flutter 环境的镜像，进行测试打包build:  stage: build  image: cirrusci/flutter:stable  only:    - tags  script:    - flutter packages get    - flutter test    - flutter build apk --release  artifacts:    expire_in: 1 hour    paths:      - build/app/outputs/apk/release/*.apk  interruptible: true// 发布到仓库的 releaserelease:  image: inetprocess/gitlab-release  stage: release  only:    - tags  dependencies:    - build  script:    // 使用打包好的 apk 文件路径    - gitlab-release --message &#39;自动发布&#39; build/app/outputs/apk/release/*.apk</code></pre><p>发布还需要一个 <code>Personal Access Token</code> 给 release 任务提供 api 权限，有了 api 权限就可以请求 Gitlab 的 release 接口上传 apk 了</p><p><img src="./images/gitlib-token.jpg" alt="token"></p><p>使用刚才创建的 token 在项目仓库里配置流水线的环境变量 <code>GITLAB_ACCESS_TOKEN</code></p><p><img src="./images/gitlab-variable.jpg" alt="var"></p><p>最后创建一个版本标签推送到 Gitlab 仓库，就可以看到运行中的流水线了</p><pre><code class="sh">git tag v1.0.0git push --tag</code></pre><p><img src="./images/gitlib-pineline.jpg" alt="var"></p><p>流水线运行完毕，一个版本发布成功。</p><p><img src="./images/gitlib-release.jpg" alt="var"></p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p><a href="https://www.pgyer.com/" target="_blank" rel="noopener">蒲公英</a> 平台可以对应用进行内测分发，使用蒲公英提供的上传应用包的接口，将 <code>CI/CD</code> 构建出来的应用 <code>apk</code> 直接上传，免去手动去网页上上传的麻烦</p><p>添加一个 <code>upload</code> 任务，依赖于 <code>build</code> 任务，向蒲公英的上传接口发送一个请求，<code>$APK_PATH</code> 是应用打包出来的路径，定义为一个变量方便使用;</p><pre><code class="yml">stages:  - build  - release  - upload......upload:  stage: upload  only:    - tags  dependencies:    - build  script:    - curl -S &quot;http://www.pgyer.com/apiv2/app/upload&quot; -F &quot;file=@$APK_PATH&quot; -F &quot;_api_key=$PGY_API_KEY&quot;    - echo uploaded</code></pre><p><code>$PGY_API_KEY</code> 是蒲公英平台的 <code>API Key</code>，需要添加到 <code>CI/CD</code> 的环境变量中</p><p><img src="./images/pgy-api-key.png" alt="api-key"></p><p>在仓库的设置那里添加新的环境变量</p><p><img src="./images/gitlab-pgy-variable.png" alt="variable"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>添加流水线配置 <code>.gitlab-ci.yml</code></li><li>创建 <code>Personal Access Token</code></li><li>设置环境变量 <code>GITLAB_ACCESS_TOKEN</code></li><li>推送版本标签</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/inetprocess/gitlab-release" target="_blank" rel="noopener">Gitlab Release</a></p><p><a href="https://docs.gitlab.com/ee/ci/quick_start/README.html" target="_blank" rel="noopener">Getting started with GitLab CI/CD</a></p><p><a href="https://www.pgyer.com/doc/view/travis_android" target="_blank" rel="noopener">使用 Travis CI 实现持续集成 (Android)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/samuel-chenard.jpg&quot; alt=&quot;action&quot;&gt;&lt;/p&gt;&lt;p&gt;本文介绍如何使用 Gitlib CI/CD 构建发布 Flutter 应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
      <category term="Gitlib" scheme="https://coldstone.fun/tags/Gitlib/"/>
    
  </entry>
  
  <entry>
    <title>使用 Github Actions 持续发布 Flutter 应用</title>
    <link href="https://coldstone.fun/post/2020/02/26/flutter-github-actions/"/>
    <id>https://coldstone.fun/post/2020/02/26/flutter-github-actions/</id>
    <published>2020-02-26T17:59:06.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/flutter-action-sm.jpg" alt="action"></p><p>本文讲解如何使用 Github Actions 构建并发布 Flutter 应用</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://help.github.com/en/actions" target="_blank" rel="noopener">Github Actions</a> 是 Github 提供的一种 CI/CD 服务，如果你的 Flutter 应用代码放在 Github 上，那就可以使用这个服务自动化进行应用测试，构建，发布工作了。</p><p>先说下 Github Actions 几个核心概念，感觉还是挺易懂的，不得不说 Github Actions 的设计很厉害 😄</p><p><strong><code>Workflow file</code></strong></p><p>配置工作流程的文件，YAML 格式，放在项目根目录的 <code>.github/workflows</code> 目录内</p><p><strong><code>Workflow</code></strong></p><p>由配置文件定义的一个工作流程，由一系列的的任务组成</p><p><strong><code>Job</code></strong></p><p>工作流程中的一个任务，由一系列的步骤 Step 组成</p><p><strong><code>Step</code></strong></p><p>一个任务其中的一个执行步骤，执行一些命令或者 Action</p><p><strong><code>Action</code></strong></p><p>一个步骤中的具体要进行操作，如拉取代码，发送请求等，可以使用自己或社区共享的 Action</p><p><strong><code>Event</code></strong></p><p>触发工作流程运行的事件，比如推送代码到仓库 push，创建一个版本标签 tag 等</p><p><strong><code>Artifact</code></strong></p><p>工程流程执行时产生的东西</p><p><strong><code>Runner</code></strong></p><p>就是工作流程运行的地方，Github 提供的服务器</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面用一个示例项目来说明如何使用 Github Actions 发布 Flutter 应用，先放成果 <a href="https://github.com/xrr2016/flutter-github-gitlab/releases" target="_blank" rel="noopener">地址</a></p><p><img src="./images/flutter-release.jpg" alt="main.yml"></p><ol><li>首先创建一个 Flutter 项目</li></ol><pre><code class="sh">flutter create flutter_github_actions</code></pre><ol start="2"><li>添加一个配置文件 <code>.github/workflows/main.yml</code></li></ol><p><img src="./images/main-yml.jpg" alt="main.yml"></p><ol start="3"><li>配置工作流程，将代码推送到 Github</li></ol><pre><code class="yml"># main.yml# 工作流程的名字name: Test, Build and Release apk# 工作流程触发的时机，这里是当一个版本标签推送到仓库时触发on:  push:    tags:      - v*# 这个工作流程需要执行的任务jobs:  process:    name: all process    runs-on: ubuntu-latest    # 这个任务的步骤    steps:      # 拉取项目代码      - uses: actions/checkout@v2      # 建立 java 环境      - name: Setup Java JDK        uses: actions/setup-java@v1.3.0        with:          java-version: &quot;12.x&quot;      # 建立 Flutter 环境      - name: Flutter action        uses: subosito/flutter-action@v1.1.1        with:          channel: &quot;stable&quot;          flutter-version: &quot;1.12.x&quot;      # 下载项目依赖      - run: flutter pub get      # 执行测试      - run: flutter test      # 打包 APK      - run: flutter build apk --release      # 发布到 Release      - name: Release apk        uses: ncipollo/release-action@v1.5.0        with:          artifacts: &quot;build/app/outputs/apk/release/*.apk&quot;          token: ${{ secrets.GITHUB_RElEASE_TOKEN }}</code></pre><ol start="4"><li>创建 Token</li></ol><p>要把构建出来的 apk 发布到仓库的 Release，还需要创建一个 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal access token</a> 提供发布 action 访问和操作代码仓库的权限，注意不要关闭浏览器标签，因为这个 token 只有在第一次创建的时候可见。</p><p><img src="./images/flutter-gtihub-token.jpg" alt="token"></p><ol start="5"><li>添加环境变量</li></ol><p>最后为了能在工作流程中创建的 token，需要在仓库的 secrets 里添加一个环境变量 <code>GITHUB_RElEASE_TOKEN</code> 来储存 token 值</p><p><img src="./images/github-secrets.jpg" alt="secrets"></p><ol start="6"><li>触发构建</li></ol><p>最后创建一个版本标签，推送到仓库触发工作流程</p><pre><code class="sh">git tag v1.0.0git push --tag</code></pre><p>然后就可以在仓库的 Actions 里面看到正在运行的工作流程了</p><p><img src="./images/github-workflow.jpg" alt="workflow"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下就是以下 4 个步骤</p><ol><li>创建一个工作流程的配置文件 <code>.github/workflows/main.yml</code></li><li>创建一个 Personnal access token</li><li>在项目的 serect 里面添加一个环境变量 <code>GITHUB_RElEASE_TOKEN</code></li><li>推送一个版本标签🏷️，触发工作流程</li></ol><p>之后就可以在每次发布标签后自动发布了</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>构建 Web 应用，发布到 Gihub Pages</p><pre><code class="yml"># 启用 Flutter web- name: Enable flutter web  run: flutter config --enable-web# 构建 web 应用- name: Build Web App  run: flutter build web# 部署到 Github Pages- name: deploy  uses: peaceiris/actions-gh-pages@v3  with:    github_token: ${{ secrets.TOKEN }}    publish_dir: ./build/web</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/flutter-action-sm.jpg&quot; alt=&quot;action&quot;&gt;&lt;/p&gt;&lt;p&gt;本文讲解如何使用 Github Actions 构建并发布 Flutter 应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
      <category term="Github Actions" scheme="https://coldstone.fun/tags/Github-Actions/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 入门笔记 📒</title>
    <link href="https://coldstone.fun/post/2020/02/12/mysql-getting-start/"/>
    <id>https://coldstone.fun/post/2020/02/12/mysql-getting-start/</id>
    <published>2020-02-12T07:37:26.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1489875347897-49f64b51c1f8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80" alt="mysql"></p><p>工作需求学习一下 MySQL 数据库</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是 MySQL？引用官方说明</p><blockquote><p>MySQL is the world’s most popular open source database. Whether you are a fast growing web property, technology ISV or large enterprise, MySQL can cost-effectively help you deliver high performance, scalable database applications.</p><p>MySQL 是世界上最受欢迎的开源数据库。无论您是快速增长的 Web 资产，技术 ISV 还是大型企业，MySQL 都能经济高效地帮助您交付高性能，可扩展的数据库应用程序。</p></blockquote><p>MySQL 是目前最流行的关系型数据库，国内外很多公司都在使用，作为一个应用开发人员还是有必要学习一下 MySQL 的基本知识的。</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>使用 Docker 运行一个 MySQL 容器</p><pre><code class="s">docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=1234 -d -v volume_folder -p 3306:3306 mysql:5</code></pre><p>命令行登录 MySQL</p><pre><code class="s">docker exec -it my-mysql bash</code></pre><pre><code class="s">mysql -u root -p</code></pre><p>创建数据库</p><pre><code class="sql">CREATE DATABASE db-name;</code></pre><p>显示数据库列表</p><pre><code class="sql">show databases;</code></pre><p>选择数据库</p><pre><code class="sql">use dbname;</code></pre><p>显示数据表</p><pre><code class="sql">show tables;</code></pre><p>创建数据表</p><pre><code class="sql">DROP TABLE IF EXISTS `user`;CREATE TABLE user(    `id`                 bigint(11)   NOT NULL AUTO_INCREMENT,    `user_id`            bigint(11)   NOT NULL COMMENT &#39;用户id&#39;,    `username`           varchar(45)  NOT NULL COMMENT &#39;真实姓名&#39;,    `email`              varchar(30)  NOT NULL COMMENT &#39;用户邮箱&#39;,    `nickname`           varchar(45)  NOT NULL COMMENT &#39;昵称&#39;,    `avatar`             int(11)      NOT NULL COMMENT &#39;头像&#39;,    `birthday`           date         NOT NULL COMMENT &#39;生日&#39;,    `gender`                tinyint(4)   DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,    `bio`    varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多150个汉字&#39;,    `user_resume`        varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,    `user_register_ip`   int          NOT NULL COMMENT &#39;用户注册时的源ip&#39;,    `create_time`        timestamp    NOT NULL COMMENT &#39;用户记录创建的时间&#39;,    `update_time`        timestamp    NOT NULL COMMENT &#39;用户资料修改的时间&#39;,    `user_review_status` tinyint      NOT NULL COMMENT &#39;用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核&#39;,    PRIMARY KEY (`id`),    UNIQUE KEY `idx_user_id` (`user_id`),    KEY `idx_username` (`username`),    KEY `idx_create_time` (`create_time`, `user_review_status`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT =&#39;网站用户基本信息&#39;;</code></pre><p>插入数据</p><pre><code class="sql">INSERT INTO table_name ( field1, field2 ) VALUES ( value1, value2 );INSERT INTO table_name SET field1=1,field2=2;</code></pre><p>查询数据</p><pre><code class="sql">SELECT username FROM table_name where id=1 limit 1;</code></pre><p>更新数据</p><pre><code class="sql">update table_name set username=&#39;update&#39; where id=1;</code></pre><p>删除数据</p><pre><code class="sql">delete from table_name where id=1;</code></pre><p>WHERE 有条件地从表中选取数据</p><pre><code class="sql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2.....</code></pre><p>LIKE 有条件地从表中选取数据</p><pre><code class="sql">SELECT field1, field2,...fieldNFROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = &#39;somevalue&#39;</code></pre><p>UNION 连接 SELECT 语句的结果组合到一个结果集合中</p><pre><code class="sql">SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions];</code></pre><p>JOIN 根据两个或多个表中的列之间的关系从中查询数据</p><pre><code class="sql">SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName;</code></pre><p>查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</p><pre><code class="sql">select * from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)</code></pre><p>删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</p><pre><code class="sql">delete from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)</code></pre><p>显示数据表的结构</p><pre><code class="sql">describe table_name;</code></pre><p>添加列</p><pre><code class="sql">alter table 表名 add 列名 列数据类型 [after 插入位置];</code></pre><p>修改列</p><pre><code class="sql">alter table 表名 change 列名称 列新名称 新数据类型;</code></pre><p>删除列</p><pre><code class="sql">alter table 表名 drop 列名称;</code></pre><p>重命名表</p><pre><code class="sql">alter table 表名 rename 新表名;</code></pre><p>清空数据表</p><pre><code class="sql">delete from table_name;</code></pre><p>删除数据表</p><pre><code class="sql">drop table table_name;</code></pre><p>删除数据库</p><pre><code class="sql">drop database dbname;</code></pre><p>退出 MySQL</p><pre><code class="sql">exit</code></pre><h2 id="SQL-执行流程"><a href="#SQL-执行流程" class="headerlink" title="SQL 执行流程"></a>SQL 执行流程</h2><ol><li>当客户端连接到MySQL服务器时，服务器对其进行认证。可以通过用户名与密码认证，也可以通过SSL证书进行认证。登录认证后，服务器还会验证客户端是否有执行某个查询的操作权限。</li><li>在正式查询之前，服务器会检查查询缓存，如果能找到对应的查询，则不必进行查询解析，优化，执行等过程，直接返回缓存中的结果集。</li><li>MySQL的解析器会根据查询语句，构造出一个解析树，主要用于根据语法规则来验证语句是否正确，比如SQL的关键字是否正确，关键字的顺序是否正确。而预处理器主要是进一步校验，比如表名，字段名是否正确等</li><li>查询优化器将解析树转化为查询计划，一般情况下，一条查询可以有很多种执行方式，最终返回相同的结果，优化器就是根据成本找到这其中最优的执行计划</li><li>执行计划调用查询执行引擎，而查询引擎通过一系列API接口查询到数据</li><li>得到数据之后，在返回给客户端的同时，会将数据存在查询缓存中</li></ol><h2 id="使用-MySQL"><a href="#使用-MySQL" class="headerlink" title="使用 MySQL"></a>使用 MySQL</h2><p>使用 DataGrip 链接 MySQL</p><p><img src="/images/mysql-datagrip.jpg" alt="folder"></p><p>在 Egg.js 中使用 MySQL 数据库</p><pre><code class="js">module.exports = () =&gt; {  return {    sequelize: {      dialect: &#39;mysql&#39;,      database: &#39;database-name&#39;,      host: &#39;127.0.0.1&#39;,      port: &#39;3306&#39;,      username: &#39;root&#39;,      password: &#39;my-secret-pw&#39;,      pool: {        max: 8, // 最大连接数        min: 0, // 最小连接数        idle: 10000, // connection释放前的最大空闲时间      },      timezone: &#39;+08:00&#39;,    },  };};</code></pre><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>MySQL 官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。是针对表而建立的，它是由数据页面以外的索引页面组成，每个索引页中的行都含有逻辑指针，以便加速检索物理数据，创建索引的目的在于提高查询效率。</p><p>MyISAM</p><p>MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p>InnoDB</p><p>在 InnoDB 中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。</p><p>创建使用索引的原则</p><p>1、索引尽量少，索引过多，影响写速度<br>2、建立索引尽量满足左匹配，索引只能命中最左边的范围查询，比如存在索引idx_a_b_c_d, 查询如select * from table where a=1 and b=2 and c&gt;3 and d&lt;4，则只能用到a,b,c<br>3、使用explain查看执行计划，需求所有的查询至少到达range级别<br>4、区分度不高的字段不建索引，比如性别，只有男和女，这种字段不需要建索引<br>5、表必须有主键索引，PRIMARY KEY (<code>id</code>)<br>6、建立索引时，把区分度高的字段放在前面</p><h2 id="建表三范式"><a href="#建表三范式" class="headerlink" title="建表三范式"></a>建表三范式</h2><ol><li>要求有主键，并且要求每一个字段原子性不可再分</li><li>第一范式基础上，要求所有非主键字段完全依赖主键，不能产生部分依赖</li><li>在第二范式基础上，所有非主键字段和主键字段之间不能产生传递依赖</li></ol><h2 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h2><p>命名规范</p><ul><li>表名不使用复数名词</li><li>库名、表名、字段名使用小写字母，下划线 “_” 分割</li><li>库名、表名、字段名不超过 12 个字符</li><li>表名不使用复数名词</li><li>库名、表名、字段名见名知意, 尽量使用名词不是动词</li><li>不使用数据库保留字比如：key，desc，delete，order……</li><li>表的命名使用 “统一前缀_业务名称_表的作用” 模式，如：tb_plan, tb_task, tb_target</li></ul><p>设计规范</p><ul><li>使用布尔值类型存储是/否类字段</li><li>禁止在表中建立预留字段</li><li>所有表和字段都需添加注释</li><li>禁止在数据库存储图片、文件等二进制数据</li><li>存储引擎选择 InnoDB，表字符集选择 utf8mb4</li><li>将大字段拆分值其他表中</li><li>字段小写命名，禁止出现大写</li><li>尽可能把所有列定义为 NOT NULL，因为 NULL 在 MySQL 中得特殊处理、很难优化</li><li>优先选择符合存储需要的最小数据类型</li><li>对于非负整数，优先使用无符号整型存储（id）</li><li>避免使用 TEXT、BLOB 数据类型，非用不可的情况，可以把 BLOB 和 TEXT 拆分到单独的拓展表中</li><li>使用 TIMESTAMP 或 DATETIME 类型存储时间<ul><li>TIMESTAMP（4BYTE）1970-01-01 00:00:01 - 2038-01-19 03:14:07</li><li>DATETIME（8BYTE）1000-01-01 00:00:00’ - 9999-12-31 23:59:59</li></ul></li><li>用 decimal 来存储金额字段，不要用 float 和 double，会出现数据精度丢失</li><li>使用 INT UNSIGNED 存储 IP，IP 转数字函数 inet_aton()、数字转 IP 函数 inet_ntoa()</li><li>VARCHAR(N) 中的 N 表示字符数(不是字节数、比如 VARCHAR(N) 能存储 N 个汉字)、满足需求的情况下 N 越小越好、最大长度65535个字节</li><li>对于定长的字符类型、比如密码 MD5 值等、建议用 char 类型，效率可以得到提升</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>Optimize Your Queries For the Query Cache</li><li>EXPLAIN Your SELECT Queries</li><li>LIMIT 1 When Getting a Unique Row</li><li>Index the Search Fields</li><li>Index and Use Same Column Types for Joins</li><li>Avoid SELECT *</li><li>Almost Always Have an id Field</li><li>Use ENUM over VARCHAR</li><li>Get Suggestions with PROCEDURE ANALYSE()</li><li>Use NOT NULL If You Can</li><li>Prepared Statements</li><li>Unbuffered Queries</li><li>Fixed-length(Static) Tables are Faster</li><li>Vertical Partitioning</li><li>Split the Big DELETE or INSERT Queries</li><li>Smaller Columns Are Faster</li><li>Choose the Right Storage Engine</li><li>Use an Object Relational Mapper</li><li>在使用 InnoDB 存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</li><li>禁止从开发环境、测试环境直连生产环境数据库</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程</a></p><p><a href="https://www.kancloud.cn/xuying/sql/269824" target="_blank" rel="noopener">数据库经验小结</a></p><p><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/21-minutes-MySQL-basic-entry.md" target="_blank" rel="noopener">21分钟MySQL基础入门</a></p><p><a href="https://www.jianshu.com/p/3e97c2a1687b" target="_blank" rel="noopener">MySql–数据库设计三范式</a></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p><a href="https://www.cnblogs.com/enein/archive/2012/11/29/2794896.html" target="_blank" rel="noopener">Top 20+ MySQL Best Practices(20条MySQL最佳实践)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1489875347897-49f64b51c1f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2250&amp;q=80&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;&lt;p&gt;工作需求学习一下 MySQL 数据库&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://coldstone.fun/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>使用 Codemagic 持续部署 Flutter 应用</title>
    <link href="https://coldstone.fun/post/2020/02/03/flutter-cicd/"/>
    <id>https://coldstone.fun/post/2020/02/03/flutter-cicd/</id>
    <published>2020-02-03T14:36:16.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<img src="https://blog.codemagic.io/uploads/2019/01/FB-build-test-publish-100.fdfb1baaca70728207ad87f5a7e36350d8c8e0693eff9616cc6758134c5542e0.jpg" alt="Codemagic" width="672"><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续集成和持续部署能够自动化应用开发的测试，构建和部署过程，如果在应用开发初期解决了这个问题无疑提升应用的开发，交付效率。</p><h2 id="什么是-Codemagic"><a href="#什么是-Codemagic" class="headerlink" title="什么是 Codemagic"></a>什么是 <code>Codemagic</code></h2><p><a href="https://codemagic.io" target="_blank" rel="noopener">Codemagic</a> 是一个为 <code>Flutter</code> 项目以及其它移动端项目提供 CI/CD 服务的平台。</p><p>可以使用 Github 账号注册登录，登录后它会要求获得你仓库的读/写权限，然后在 <a href="https://codemagic.io/apps" target="_blank" rel="noopener">apps</a> 页面显示你需要进行构建的项目。</p><p><img src="./images/code-apps.jpg" alt="code-apps"></p><h2 id="为什么使用-Codemagic"><a href="#为什么使用-Codemagic" class="headerlink" title="为什么使用 Codemagic"></a>为什么使用 <code>Codemagic</code></h2><p>好的 <code>CI/CD</code> 有助于更快地构建，测试以及部署发布应用。在 <code>Flutter</code> 的官方文档 <a href="https://flutter.cn/docs/deployment/cd" target="_blank" rel="noopener">Flutter 里的持续部署</a> 里介绍了使用 <code>fastlane</code> 工具进行本地部署以及如何将 <code>fastlane</code> 整合到 <code>Travis</code>，<code>Cirrus</code>，<code>Bitrise</code> 等持续交付的服务中，但是对于 <code>Flutter</code> 项目来说最方便的 <code>CI/CD</code> 服务应该还是 <code>Codemagic</code>，它可以直接在网页上就配置出完整的应用交付流程。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>选择需要构建的 <code>Fluter</code> 项目，点击 <code>Start your first build</code> 按钮，创建一个工作流程 <code>Workflow</code>。<br>一个 <code>Workflow</code> 指的是每次构建要做的任务，如执行构建，测试以及发布任务。</p><p>对于 <code>Flutter</code> 项目可以在网页上配置或使用 <code>codemagic.yaml</code> 配置文件，其它项目只能使用 <code>codemagic.yaml</code> 配置。</p><p><img src="./images/workflow.jpg" alt="workflow"></p><p>一个 <code>Workflow</code> 由以下几个部分组成</p><ol><li><code>Build triggers</code> –&gt; 指定的构建分支和触发构建的时机</li></ol><p><img src="./images/build-triggers.jpg" alt="build-triggers"></p><ol start="2"><li><code>Environment variables</code> –&gt; 设置构建时的环境变量</li></ol><p><img src="https://docs.codemagic.io/uploads/env_vars.PNG" alt="env_vars"></p><ol start="3"><li><code>Dependency caching</code> –&gt; 设置构建时的依赖缓存文件目录，加快构建速度</li></ol><p><img src="https://docs.codemagic.io/uploads/2019/04/caching_enabled.PNG" alt="caching"></p><ol start="4"><li><code>Test</code> –&gt; 执行应用的单元，集成和部件测试，以及静态代码分析</li></ol><p><img src="./images/code-test.jpg" alt="code-test"></p><ol start="5"><li><code>Build</code> –&gt; 配置应用构建时的 Flutter 版本，构建目标，构建参数</li></ol><p><img src="./images/code-build.jpg" alt="code-build"></p><ol start="6"><li><code>Publish</code> –&gt; 选择需要发布应用的目标，这里我选择了 <code>Google play</code></li></ol><p><img src="./images/code-publish.jpg" alt="code-publish"></p><h2 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h2><p>要将应用发布到 <code>Apple store</code> 或者 <code>Goople play</code> 上就必须对你的应用进行代码签名，代码签名目的是为了识别谁开发了该应用程序，并确保该应用程序的所有更新均来自这个人。</p><p>对于 Android 来说有两种签名：发布签名和上传签名。最终用户下载的 <code>.aab/.apk</code> 文件使用发布签名。上传签名提供给开发者上传到 <code>Google Play</code> 商店的认证。上传后，<code>Google Play</code> 会重新使用发布签名对 <code>.aab/.apk</code> 文件签名。</p><p>在配置 <code>Workflow</code> 时，我选择发布到 <code>Goople play</code> 所以需要对 Android 应用进行代码签名，有以下两种方式进行签名，选择其一即可。</p><ol><li>使用 <code>Android Studio</code> <a href="https://developer.android.google.cn/studio/publish/app-signing#sign-apk" target="_blank" rel="noopener">为您的应用签名</a></li><li>使用命令行工具进行签名 <a href="https://flutter.cn/docs/deployment/android#signing-the-app" target="_blank" rel="noopener">为 app 签名</a></li></ol><p>签名后需要做的是把签名信息存到工作流程 <code>Workflow</code> 内，<a href="https://docs.codemagic.io/code-signing/android-code-signing/" target="_blank" rel="noopener">Android code signing</a>。</p><h2 id="创建-Service-Account"><a href="#创建-Service-Account" class="headerlink" title="创建 Service Account"></a>创建 <code>Service Account</code></h2><p><code>Service Account</code> 是给 <code>CI/CD</code> 平台发布构建后应用用的，根据指引创建 <a href="https://docs.codemagic.io/publishing/publishing-to-google-play/#setting-up-a-service-account-in-google-play-console" target="_blank" rel="noopener">Setting up a service account in Google Play Console</a>，创建后需做的上传你的凭证 JSON 文件</p><p><img src="./images/code-google-play.jpg" alt="code-google-play"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>在使用 <code>CI/CD</code> 服务前首先要人工的上传应用到 <code>Google Play</code> 一次。</li><li>每次上传到 <code>Google Play</code> 的应用构建版本不能重复，否则会遇到这样一个问题</li></ol><pre><code class="sh">Google Play responded with: APK specifies a version code that has already been used.</code></pre><p>搜索一番后发现问题是应用构建的版本号重复，需要更新 <code>pubspec.yaml</code> 文件的 <code>version</code> 字段的值，详细说明可以查阅这篇文章 <a href="https://flutter.cn/docs/deployment/android#updating-the-apps-version-number" target="_blank" rel="noopener">更新应用版本号</a></p><ol start="3"><li>上传 <code>Google Play</code> 需要添加一个环境变量 <code>FCI_KEYSTORE_FILE</code>，这个变量需要用 base64 encode 一下，需要用到的命令是<pre><code class="sh">base64 input-file-path -o output.txt</code></pre></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>Codemagic</code> 发布 Flutter 应用的流程大致如下</p><ol><li>选择构建项目</li><li>配置构建流程</li><li>进行代码签名</li><li>创建 Service Account</li><li>触发构建</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://flutter.cn/docs/deployment/cd" target="_blank" rel="noopener">Flutter 里的持续部署</a></p><p><a href="https://docs.codemagic.io/" target="_blank" rel="noopener">Codemagic Documentation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://blog.codemagic.io/uploads/2019/01/FB-build-test-publish-100.fdfb1baaca70728207ad87f5a7e36350d8c8e0693eff9616cc6758134c5542e0.jpg&quot; alt=&quot;Codemagic&quot; width=&quot;672&quot;&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
      <category term="Codemagic" scheme="https://coldstone.fun/tags/Codemagic/"/>
    
      <category term="Google Play" scheme="https://coldstone.fun/tags/Google-Play/"/>
    
  </entry>
  
  <entry>
    <title>为 Flutter 应用添加搜索功能</title>
    <link href="https://coldstone.fun/post/2020/01/26/flutter-show-search/"/>
    <id>https://coldstone.fun/post/2020/01/26/flutter-show-search/</id>
    <published>2020-01-26T09:34:54.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<img src="images/flutter_show_search.png" height="320" style="height:340px;object-fit:cover"><p>使用 <code>SearchDelegate</code> 给 Flutter 应用添加搜索功能</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>SearchDelegate</code> 是 Flutter 框架提供的一个实现搜索功能的类，使用它可以快速实现搜索功能，本文说明如何使用它来实现搜索功能。</p><p>最终效果如下</p><div><video src="videos/show_search.mov" controls width="240" autoplay muted loop></div><p>创建新项目，初始化代码如下</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;void main() {  runApp(MyApp());}class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Search App&#39;,      home: HomePage(),    );  }}class HomePage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Search App&#39;),      ),    );  }}</code></pre><h2 id="显示搜索页面"><a href="#显示搜索页面" class="headerlink" title="显示搜索页面"></a>显示搜索页面</h2><p><code>showSearch</code> 方法是 Flutter 里用来显示一个搜索页面的方法，这个页面由一个带有搜索框的 <code>AppBar</code> 和显示搜索建议或搜索结果的 <code>body</code> 组成。它有两个必要参数 <code>context</code> 和 <code>delegate</code>，<code>context</code> 即为当前的应用上下文，<code>delegate</code> 是一个实现了 <code>SearchDelegate</code> 抽象类自定义的部件，这个自定义部件定义了如何显示搜索页面，关闭搜索页面时返回用户选择的搜索结果。</p><p>在 <code>AppBar</code> 的 <code>actions</code> 数组里面添加一个 <code>IconButton</code>，按下时调用 <code>showSearch</code> 方法，进入搜索页面。</p><pre><code class="dart">class HomePage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Search App&#39;),        actions: &lt;Widget&gt;[          IconButton(            icon: Icon(Icons.search),            onPressed: () {              showSearch(context: context, delegate: CustomSearchDelegate());            },          )        ],      ),    );  }}</code></pre><p>初始化一个继承了 <code>SearchDelegate</code> 的 <code>CustomSearchDelegate</code>，类的名字是自定义的。</p><pre><code class="dart">class CustomSearchDelegate extends SearchDelegate {  @override  List&lt;Widget&gt; buildActions(BuildContext context) {    // TODO: implement buildActions    throw UnimplementedError();  }  @override  Widget buildLeading(BuildContext context) {    // TODO: implement buildLeading    throw UnimplementedError();  }  @override  Widget buildResults(BuildContext context) {    // TODO: implement buildResults    throw UnimplementedError();  }  @override  Widget buildSuggestions(BuildContext context) {    // TODO: implement buildSuggestions    throw UnimplementedError();  }}</code></pre><h2 id="实现-CustomSearchDelegate"><a href="#实现-CustomSearchDelegate" class="headerlink" title="实现 CustomSearchDelegate"></a>实现 <code>CustomSearchDelegate</code></h2><p>自定义的 <code>CustomSearchDelegate</code> 需要实现四个方法</p><ul><li><code>buildLeading</code> 显示在输入框之前的部件，一般显示返回前一个页面箭头按钮</li><li><code>buildActions</code> 显示在输入框之后的部件</li><li><code>buildResults</code> 显示搜索结果</li><li><code>buildSuggestions</code> 显示搜索建议</li></ul><p>先实现 <code>buildActions</code> 和 <code>buildLeading</code>，<code>buildActions</code> 显示一个清除按钮，可以把当前的 <code>query</code> 查询参数清空，并显示搜索建议。<code>buildLeading</code> 显示一个箭头的按钮，使用 <code>close</code> 方法关闭搜索页面，<code>close</code> 方法第二个参数是选定的搜索结果，如果使用系统后退按钮关闭搜索页面，则返回 <code>null</code> 值。</p><pre><code class="dart">List&lt;Widget&gt; buildActions(BuildContext context) {  return [    IconButton(      tooltip: &#39;Clear&#39;,      icon: const Icon(Icons.clear),      onPressed: () {        query = &#39;&#39;;        showSuggestions(context);      },    )  ];}@overrideWidget buildLeading(BuildContext context) {  return IconButton(    tooltip: &#39;Back&#39;,    icon: AnimatedIcon(      icon: AnimatedIcons.menu_arrow,      progress: transitionAnimation,    ),    onPressed: () {      close(context, null);    },  );}@overrideWidget buildResults(BuildContext context) {  return ListView();}@overrideWidget buildSuggestions(BuildContext context) {  return ListView();}</code></pre><img src="images/search_01.png" width="240" style="width:240px"><p>然后实现 <code>buildResults</code> 和 <code>buildSuggestions</code>，这两个方法用来展示搜索页面内容，可以使用不同的部显示，这里使用 <code>ListView</code> 部件。</p><pre><code class="dart">@overrideWidget buildResults(BuildContext context) {  return ListView.builder(    itemCount: Random().nextInt(10),    itemBuilder: (context, index) {      return ListTile(        title: Text(&#39;result $index&#39;),      );    },  );}@overrideWidget buildSuggestions(BuildContext context) {  return ListView(    children: &lt;Widget&gt;[      ListTile(title: Text(&#39;Suggest 01&#39;)),      ListTile(title: Text(&#39;Suggest 02&#39;)),      ListTile(title: Text(&#39;Suggest 03&#39;)),      ListTile(title: Text(&#39;Suggest 04&#39;)),      ListTile(title: Text(&#39;Suggest 05&#39;)),    ],  );}</code></pre><p>搜索结果</p><img src="images/search_result.png" width="240" style="width:240px"><p>搜索建议</p><img src="images/search_suggestion.png" width="240" style="width:240px"><h2 id="获取远程数据"><a href="#获取远程数据" class="headerlink" title="获取远程数据"></a>获取远程数据</h2><p>搜索功能一般需要请求后端的搜索接口来获取数据，此时可以使用 <code>FutureBuilder</code> 部件来请求数据然后渲染结果。首先需要定义一个请求接口的方法，返回一个 <code>Future</code>，然后在 <code>buildResults</code> 方法中使用 <code>FutureBuilder</code> 来展示结果。</p><p>先添加 <code>http</code> 包，用来发送 http 请求，然后引入需要的依赖包</p><pre><code class="yml">dependencies:  http: &lt;latest_version&gt;</code></pre><pre><code class="dart">import &#39;dart:convert&#39;;import &#39;package:http/http.dart&#39; as http;</code></pre><p>将键盘输入类型设置为数字，定义一个 <code>_fetchPosts</code> 方法用来获取远端数据，在 <code>buildResults</code> 方法里使用 <code>FutureBuilder</code> 渲染搜索结果。</p><pre><code class="dart">@overrideTextInputType get keyboardType =&gt; TextInputType.number;Future _fetchPosts() async {  http.Response response =      await http.get(&#39;https://jsonplaceholder.typicode.com/posts/$query&#39;);  final data = await json.decode(response.body);  return data;}@overrideWidget buildResults(BuildContext context) {  if (int.tryParse(query) &gt;= 100) {    return Center(child: Text(&#39;请输入小于 100 的数字&#39;));  }  return FutureBuilder(    future: _fetchPosts(),    builder: (context, AsyncSnapshot snapshot) {      if (snapshot.hasData) {        final post = snapshot.data;        return ListTile(          title: Text(post[&#39;title&#39;], maxLines: 1),          subtitle: Text(post[&#39;body&#39;], maxLines: 3),        );      }      return Center(child: CircularProgressIndicator());    },  );}</code></pre><img src="images/search_server.png" width="240" style="width:240px"><p>使用 <code>FutureBuilder</code> 部件获取了远程的数据，但是遇到一个问题，搜索结果可能是分页显示的，一开始只获取了第一页的数据，想追加下一页数据时需要像 <code>stateFullWidget</code> 那样使用 <code>setState</code> 方法更新页面，但是在 <code>SearchDelegate</code> 里无法使用…暂时没想到解决方法。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="dart">import &#39;dart:convert&#39;;import &#39;package:flutter/material.dart&#39;;import &#39;package:http/http.dart&#39; as http;void main() {  runApp(MyApp());}class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Search App&#39;,      home: HomePage(),    );  }}class HomePage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Search App&#39;),        actions: &lt;Widget&gt;[          IconButton(            icon: Icon(Icons.search),            onPressed: () {              showSearch(context: context, delegate: CustomSearchDelegate());            },          )        ],      ),    );  }}class CustomSearchDelegate extends SearchDelegate {  @override  List&lt;Widget&gt; buildActions(BuildContext context) {    return [      IconButton(        tooltip: &#39;Clear&#39;,        icon: const Icon(Icons.clear),        onPressed: () {          query = &#39;&#39;;          showSuggestions(context);        },      )    ];  }  @override  Widget buildLeading(BuildContext context) {    return IconButton(      tooltip: &#39;Back&#39;,      icon: AnimatedIcon(        icon: AnimatedIcons.menu_arrow,        progress: transitionAnimation,      ),      onPressed: () {        this.close(context, null);      },    );  }  @override  TextInputType get keyboardType =&gt; TextInputType.number;  Future _fetchPosts() async {    http.Response response =        await http.get(&#39;https://jsonplaceholder.typicode.com/posts/$query&#39;);    final data = await json.decode(response.body);    return data;  }  @override  Widget buildResults(BuildContext context) {    if (int.parse(query) &gt;= 100) {      return Center(child: Text(&#39;请输入小于 100 的数字&#39;));    }    return FutureBuilder(      future: _fetchPosts(),      builder: (context, AsyncSnapshot snapshot) {        if (snapshot.hasData) {          final post = snapshot.data;          return ListTile(            title: Text(post[&#39;title&#39;], maxLines: 1),            subtitle: Text(post[&#39;body&#39;], maxLines: 3),          );        }        return Center(child: CircularProgressIndicator());      },    );  }  @override  Widget buildSuggestions(BuildContext context) {    return ListView(      children: &lt;Widget&gt;[        ListTile(title: Text(&#39;Suggest 01&#39;)),        ListTile(title: Text(&#39;Suggest 02&#39;)),        ListTile(title: Text(&#39;Suggest 03&#39;)),        ListTile(title: Text(&#39;Suggest 04&#39;)),        ListTile(title: Text(&#39;Suggest 05&#39;)),      ],    );  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;images/flutter_show_search.png&quot; height=&quot;320&quot; style=&quot;height:340px;object-fit:cover&quot;&gt;&lt;p&gt;使用 &lt;code&gt;SearchDelegate&lt;/code&gt; 给 Flutter 应用添加搜索功能&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 创建自定义路由过渡动画</title>
    <link href="https://coldstone.fun/post/2019/12/10/flutter-route-transition/"/>
    <id>https://coldstone.fun/post/2019/12/10/flutter-route-transition/</id>
    <published>2019-12-10T08:37:52.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/transition.jpg" alt="flutter-routes"></p><p>Flutter 应用进行路由跳转的时候有默认的过渡动画，但是自定义的跳转动画会让应用更具特色</p><a id="more"></a><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ol><li>使用 <code>PageRouteBuilder</code> 创建自定义路由</li><li>在 <code>transitionsBuilder</code> 方法里创建过渡动画</li><li>过渡动画示例</li><li>定义全局路由过渡动画</li><li>封装自定义路由</li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>Flutter</code> 中使用 <code>Navigator.of(context).push(Route route);</code> 方法进行路由跳转时就需要传一个 <code>Route</code> 对象，通常使用 <code>MaterialPageRoute(builder: () {});</code> 创建，使用时会在路由跳转过程中添加默认的过渡动画。当需要自定义路由过渡动画时，就要使用 <code>PageRouteBuilder</code>，它是 <code>Flutter</code> 提供的用来创建自定义的路由的一个类，实例化这个类会得到一个路由对象 <code>Route</code>，要做的就是创建一个自定义的 <code>Route</code>。</p><h2 id="PageRouteBuilder"><a href="#PageRouteBuilder" class="headerlink" title="PageRouteBuilder"></a>PageRouteBuilder</h2><p>使用 <code>PageRouteBuilder</code> 创建自定义路由过渡动画时需要传入两个回调函数作为参数，一个必要参数 <code>pageBuilder</code>，这个函数用来创建跳转的页面，另一个函数 <code>transitionsBuilder</code>，这个函数就是实现过渡动画的地方。</p><blockquote><p><code>transitionsBuilder</code> 的 <code>child</code> 参数是 <code>pageBuilder</code> 函数返回的一个 <code>transitionsBuilder widget</code> 部件， <code>pageBuilder</code> 方法仅会在第一次构建路由的时候被调用，<code>Flutter</code> 能够自动避免做额外的工作，整个过渡期间 <code>child</code> 保存了同一个实例。</p></blockquote><pre><code class="dart">PageRouteBuilder(  pageBuilder: (      BuildContext context,      Animation&lt;double&gt; animation,      Animation&lt;double&gt; secondaryAnimation,    ) {      return widget;    },    transitionsBuilder: (      BuildContext context,      Animation&lt;double&gt; animation,      Animation&lt;double&gt; secondaryAnimation,      Widget child,    ) {      return child;    },);</code></pre><p>创建自定义路由需要继承 <code>PageRouteBuilder</code>，然后实现自定义路由的构造函数。</p><pre><code class="dart">// 定义class YourRoute extends PageRouteBuilder {  final Widget page;  YourRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return child;          },        );}// 使用Navigator.of(context).push(YourRoute(NewPage()));</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用 <code>FirstPage</code> 和 <code>SecondPage</code> 两个页面展示效果</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      debugShowCheckedModeBanner: false,      home: FirstPage(),    );  }}class FirstPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;First Page&#39;),        elevation: 0.0,        backgroundColor: Colors.purple,      ),      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          Center(            child: RaisedButton(              onPressed: () {                Navigator.of(context).push(                  MaterialPageRoute(builder: (context) =&gt; SecondPage()),                );              },              child: Text(&#39;Next Page&#39;),            ),          )        ],      ),      backgroundColor: Colors.purple,    );  }}class SecondPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Second Page&#39;),        elevation: 0.0,        backgroundColor: Colors.deepPurpleAccent,      ),      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          Center(            child: RaisedButton(              onPressed: () {                Navigator.pop(context);              },              child: Text(&#39;Go Back&#39;),            ),          )        ],      ),      backgroundColor: Colors.deepPurpleAccent,    );  }}</code></pre><h3 id="FadeTransition"><a href="#FadeTransition" class="headerlink" title="FadeTransition"></a><code>FadeTransition</code></h3><pre><code class="dart">class FadeRoute extends PageRouteBuilder {  final Widget page;  FadeRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return FadeTransition(              opacity: animation,              child: child,            );          },        );}</code></pre><div><video src="videos/fade_transition.mov" controls width="320" autoplay muted loop></div><h3 id="ScaleTransition"><a href="#ScaleTransition" class="headerlink" title="ScaleTransition"></a><code>ScaleTransition</code></h3><pre><code class="dart">class ScaleRoute extends PageRouteBuilder {  final Widget page;  ScaleRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return ScaleTransition(              alignment: Alignment.bottomLeft,              scale: Tween(                begin: 0.0,                end: 1.0,              ).animate(                CurvedAnimation(                  parent: animation,                  curve: Curves.easeInOut,                ),              ),              child: child,            );          },          transitionDuration: Duration(seconds: 1),        );}Navigator.of(context).push(ScaleRoute(SecondPage()));</code></pre><div><video src="videos/scale_transition.mov" controls width="320" autoplay muted loop></div><h3 id="RotationTransition"><a href="#RotationTransition" class="headerlink" title="RotationTransition"></a><code>RotationTransition</code></h3><pre><code class="dart">class RotationRoute extends PageRouteBuilder {  final Widget page;  RotationRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            Animation myAnimation = CurvedAnimation(              parent: animation,              curve: Curves.easeInBack,            );            return RotationTransition(              turns: myAnimation,              child: child,            );          },          transitionDuration: Duration(seconds: 1),        );}Navigator.of(context).push(RotationRoute(SecondPage()));</code></pre><div><video src="videos/rotation_transition.mov" controls width="320" autoplay muted loop></div><h3 id="ScaleRotationRoute"><a href="#ScaleRotationRoute" class="headerlink" title="ScaleRotationRoute"></a><code>ScaleRotationRoute</code></h3><p>结合两个过渡动画</p><pre><code class="dart">class ScaleRotationRoute extends PageRouteBuilder {  final Widget page;  ScaleRotationRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return ScaleTransition(              scale: animation,              child: RotationTransition(                turns: Tween(                  begin: 0.0,                  end: 1.0,                ).animate(                  CurvedAnimation(parent: animation, curve: Curves.linear),                ),                child: child,              ),            );          },          transitionDuration: Duration(milliseconds: 800),        );}Navigator.of(context).push(ScaleRotationRoute(SecondPage()));</code></pre><div><video src="videos/scale_rotation_transition.mov" controls width="320" autoplay muted loop></div><h3 id="TransformRoute"><a href="#TransformRoute" class="headerlink" title="TransformRoute"></a><code>TransformRoute</code></h3><p>使用 <code>Transform</code> 部件创造 <code>3D</code> 效果</p><pre><code class="dart">import &#39;dart:math&#39; show pi;class TransformRoute extends PageRouteBuilder {  final Widget page;  TransformRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return Transform(              transform: Matrix4.identity()                // 类似于 CSS 里面 `perspective` 属性，确定 z=0 平面与用户之间的距离                ..setEntry(3, 2, 0.0001)                ..rotateX(animation.value * pi * 2)                ..rotateY(animation.value * pi * 2),              alignment: FractionalOffset.center,              child: child,            );          },          transitionDuration: Duration(seconds: 2),        );}Navigator.of(context).push(TransformRoute(SecondPage()));</code></pre><div><video src="videos/transform_transition.mov" controls width="320" autoplay muted loop></div><h3 id="EnterExitRoute"><a href="#EnterExitRoute" class="headerlink" title="EnterExitRoute"></a><code>EnterExitRoute</code></h3><p>同时为进入页面和退出页面添加动画</p><pre><code class="dart">class EnterExitRoute extends PageRouteBuilder {  final Widget enterPage;  final Widget exitPage;  EnterExitRoute(this.enterPage, this.exitPage)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return exitPage;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) =&gt;              Stack(            children: [              SlideTransition(                position: Tween&lt;Offset&gt;(                  begin: Offset(0.0, 0.0),                  end: Offset(-1.0, 0.0),                ).animate(                  CurvedAnimation(parent: animation, curve: Curves.easeIn),                ),                child: enterPage,              ),              SlideTransition(                position: Tween&lt;Offset&gt;(                  begin: Offset(1.0, 0.0),                  end: Offset.zero,                ).animate(                  CurvedAnimation(parent: animation, curve: Curves.easeInOut),                ),                child: exitPage,              )            ],          ),        );}Navigator.of(context).push(  EnterExitRoute(FirstPage(), SecondPage()),);</code></pre><div><video src="videos/enter_exist_transition.mov" controls width="320" autoplay muted loop></div><h2 id="使用-Navigator-pushNamed-方法跳转"><a href="#使用-Navigator-pushNamed-方法跳转" class="headerlink" title="使用 Navigator.pushNamed 方法跳转"></a>使用 <code>Navigator.pushNamed</code> 方法跳转</h2><p>在 <code>onGenerateRoute</code> 对跳转路由的 <code>name</code> 进行判断，对特定的路由添加过渡动画。</p><pre><code class="dart">class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      debugShowCheckedModeBanner: false,      home: FirstPage(),      onGenerateRoute: (settings) {        switch (settings.name) {          case &#39;/second&#39;:            return ScaleRoute(SecondPage());            break;          default:            return null;        }      },    );  }}Navigator.pushNamed(context, &#39;/second&#39;, arguments: {});</code></pre><h2 id="设置全局的路由过渡动画"><a href="#设置全局的路由过渡动画" class="headerlink" title="设置全局的路由过渡动画"></a>设置全局的路由过渡动画</h2><p><code>Flutter</code> 的默认路由过渡动画是由 <code>buildTransitions</code> 方法创建的，它使用的是 <code>Theme.of(context).pageTransitionsTheme</code>方法，因此可以定义全局的路由跳转过渡动画。</p><pre><code class="dart">@overrideWidget buildTransitions(context, animation, secondaryAnimation, child) {    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;    return theme.buildTransitions&lt;T&gt;(this, context, animation, secondaryAnimation, child);}</code></pre><p>首先自定义一个 <code>TransitionBuilder</code>， <code>buildTransitions</code> 方法返回跳转页面。然后配置 <code>theme</code> 的 <code>pageTransitionsTheme</code>，设置对应的平台，最后在使用 <code>MaterialPageRoute</code> 或者 <code>CupertinoPageRoute</code> 进行页面跳转时就会有自定义的过渡动画了。</p><pre><code class="dart">class ScaleTransitionBuilder extends PageTransitionsBuilder {  @override  Widget buildTransitions&lt;T&gt;(    route,    context,    animation,    secondaryAnimation,    child,  ) {    return ScaleTransition(      scale: CurvedAnimation(parent: animation, curve: Curves.easeIn),      child: child,    );  }}class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      debugShowCheckedModeBanner: false,      home: FirstPage(),      theme: ThemeData(        pageTransitionsTheme: PageTransitionsTheme(          builders: {            TargetPlatform.android: ScaleTransitionBuilder(),            TargetPlatform.iOS: ScaleTransitionBuilder(),          },        ),      ),    );  }}Navigator.push(context, MaterialPageRoute(builder: (ctx) =&gt; SecondPage()));</code></pre><h2 id="将动画封装成一个库"><a href="#将动画封装成一个库" class="headerlink" title="将动画封装成一个库"></a>将动画封装成一个库</h2><p>将自定义的路由过渡动画封装起来方便使用。</p><pre><code class="dart">enum TransitionType {  fade,  scale,  rotate,  transform,}class PageTransition extends PageRouteBuilder {  PageTransition(TransitionType type, Widget page, Duration time)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            switch (type) {              case TransitionType.fade:                return FadeTransition(opacity: animation, child: child);                break;              case TransitionType.scale:                return ScaleTransition(                  scale: Tween(begin: 0.0, end: 1.0).animate(                    CurvedAnimation(parent: animation, curve: Curves.easeInOut),                  ),                  child: child,                );                break;              case TransitionType.rotate:                return RotationTransition(                  turns: CurvedAnimation(                    parent: animation,                    curve: Curves.easeInBack,                  ),                  child: child,                );                break;              case TransitionType.transform:                return Transform(                  transform: Matrix4.identity()                    ..setEntry(3, 2, 0.0001)                    ..rotateX(animation.value * pi * 2)                    ..rotateY(animation.value * pi * 2),                  alignment: FractionalOffset.center,                  child: child,                );                break;              default:                return child;            };          },          transitionDuration: time,        );}// 使用Navigator.push(  context,  PageTransition(    TransitionType.rotate,    SecondPage(),    Duration(milliseconds: 800),  ),}</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://flutter.cn/docs/cookbook/animation/page-route-animation" target="_blank" rel="noopener">为页面切换加入动画效果</a></p><p><a href="https://medium.com/flutter-community/everything-you-need-to-know-about-flutter-page-route-transition-9ef5c1b32823" target="_blank" rel="noopener">Everything you need to know about Flutter page route transition</a></p><p><a href="https://medium.com/flutter/perspective-on-flutter-6f832f4d912e" target="_blank" rel="noopener">Perspective on Flutter</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/transition.jpg&quot; alt=&quot;flutter-routes&quot;&gt;&lt;/p&gt;&lt;p&gt;Flutter 应用进行路由跳转的时候有默认的过渡动画，但是自定义的跳转动画会让应用更具特色&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Egg.js 上传接口开发总结</title>
    <link href="https://coldstone.fun/post/2019/12/05/egg-api-dev/"/>
    <id>https://coldstone.fun/post/2019/12/05/egg-api-dev/</id>
    <published>2019-12-05T12:00:00.000Z</published>
    <updated>2020-06-18T09:46:58.872Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/egg.jpg" alt="egg"></p><p>总结一下之前用 Egg.js 开发的文件上传接口的任务</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>要在浏览器端将文件上传到阿里的 OSS 对象存储，需要用到阿里云提供的 <a href="https://github.com/ali-sdk/ali-oss" target="_blank" rel="noopener">SDK</a>，但是这样会在前端暴露 OSS 的 <code>accessKeyId</code> 和 <code>accessKeySecret</code>，这是不安全的。所以需要一个文件上传接口把前端传过来的文件上传到对象存储里面，最初只支持阿里云，之后可能会支持其它的云服务商比如七牛云。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>后端框架用的是 Egg.js，因为比较熟悉。然后这只是一个文件上传的服务，一个路由就行。</p><pre><code class="js">router.post(`/${app.name}/v1/upload`, controller.oss.upload)</code></pre><p>然后实现对应的 <code>OssController</code> 的 <code>upload</code> 方法，一般的实践是在 <code>Controller</code> 层进行参数校验，这里用内置的是 <code>egg-validate</code> 插件进行校验。假如有两个参数 <code>folder</code> 和 <code>bucket</code> 代表文件上传的目录和 <code>bucket</code>，那么验证代码如下</p><pre><code class="js">const body = ctx.request.bodyconst rules = {  folder: { type: &#39;string&#39;, required: false, default: &#39;/&#39;, trim: true },  bucket: { type: &#39;string&#39;, required: false, default:  &#39;you-bucket-name&#39; },}await ctx.validate(rules, body)</code></pre><p>接受前端的上传文件用的是 <a href="https://github.com/eggjs/egg-multipart" target="_blank" rel="noopener">egg-multipart</a> 插件，这个插件有两种模式 <code>file</code> 和 <code>stream</code>，<code>file</code> 模式适合简单的文件上传，这种模式会先将前端传来的图片存到服务器上，执行完操作后需要用 <code>ctx.cleanupRequestFiles()</code> 方法将文件删除。 <code>stream</code> 模式适合在对上传文件进一步处理的时候使用，如压缩，解压等，如果上传文件是图片那么可以将这个流传递给处理图片的库进行处理。</p><p>在 <code>config.default.js</code> 配置 <code>egg-multipart</code> 插件，在 <code>fileExtensions</code> 新增需要添加的文件类型扩展名，<code>cleanSchedule</code> 配置定时清除零时保存的文件。</p><pre><code class="ts">config.multipart = {  mode: &#39;file&#39;,  fileSize: &#39;50mb&#39;,  tmpdir: path.join(os.tmpdir(), &#39;egg-multipart-tmp&#39;, appInfo.name),  cleanSchedule: {    cron: &#39;0 30 4 * * *&#39;,  },  fileExtensions: [ &#39;.pdf&#39;, &#39;.doc&#39;, &#39;.docx&#39; ],}</code></pre><p>然后用 <code>ctx.request.files</code> 获取请求过来的文件，这里也需要进行验证请求是否有文件，校验好请求参数后就把请求参数传到 <code>Services</code> 层里</p><pre><code class="js">const files = ctx.request.filesconst body = ctx.request.body...ctx.body = await ctx.service.oss.upload(body, files)</code></pre><p>对应的 <code>OssService</code> 是负责主要的任务地方，新建 <code>OSS</code> 实例对象，上传文件，设置上传文件的请求头，返回上传结果。</p><pre><code class="ts">import * as fs from &#39;fs&#39;import * as OSS from &#39;ali-oss&#39;const ONE_YEAR = 3600 * 24 * 365/** * OssService */export default class OssService extends Service {  private client  private createClient(option) {      this.client = new OSS({})    }  }  private async uploadFile(dir, file) {    let result    const filename = file.filename.replace(/\.(\w+)$/, `-${Date.now()}.$1`)    try {      result = await this.client.put(`${dir}${filename}`, file.filepath, {        headers: { &#39;Cache-Control&#39;: `max-age=${ONE_YEAR}`, &#39;Content-Disposition&#39;: &#39;&#39; },      })    } catch (e) {      this.ctx.logger.error(new Error(e.message))      throw new Error(e.message)    } finally {      fs.unlink(file.filepath, () =&gt; true)    }    return result  }  public async upload(parmas, files) {    this.createClient(parmas)    let result    if (files.length &gt; 1) {      result = []      for (const file of files) {        const res = await this.uploadFile(parmas.dir, file)        result.push({ url: res.url })      }    } else {      const file = files[0]      const res = await this.uploadFile(parmas.dir, file)      result = { url: res.url }    }    return result  }}</code></pre><p>至此上传文件到 OSS 接口基本完成了</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Egg.js 集成了 <a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">SuperTest</a> 测试框架，所以写接口的单元测试很方便。这个接口主要是对 <code>Controller</code> 层请求参数进行测试。测试代码写在项目目录 <code>test/app/controller/oss.test.ts</code> 文件内。</p><pre><code class="ts">import { app, assert } from &#39;egg-mock/bootstrap&#39;describe(&#39;测试 oss controller&#39;, () =&gt; {  it(&#39;不再白名单的 bucket 名返回错误&#39;, async () =&gt; {    const result = await app.httpRequest()      .post(&#39;/upload-server/v1/upload&#39;)      .set(&#39;Content-type&#39;, &#39;multipart/form-data; boundary=--------------------------820317025826519383208825&#39;)      .field(&#39;bucket&#39;, &#39;wrong-bucket&#39;)      .expect(403)    assert(result.body)  })  it(&#39;上传文件成功&#39;, async () =&gt; {    const result = await app.httpRequest()      .post(&#39;/upload-server/v1/upload&#39;)      .set(&#39;Content-type&#39;, &#39;multipart/form-data; boundary=--------------------------820317025826519383208825&#39;)      .field(&#39;dir&#39;, &#39;images&#39;)      .attach(&#39;avatar&#39;, &#39;test/app/controller/avatar.png&#39;)      .expect(200)    assert(result.body)  })})</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Egg.js 本身部署十分的方便，只需要在服务器上运行以下命令即可</p><pre><code class="bash">egg-scripts start --daemon --env=prod --title=upload-server</code></pre><p>但是将这个服务变成一个 <code>Docker</code> <code>iamge</code> 就更方便了</p><blockquote><p>注意:<br>要用 <code>Docker</code> 运行 Egg 服务需要将 <code>package.json</code> 中 <code>scripts</code> 的 <code>start</code> 命令去掉 <code>--daemon</code> 参数，变成<br><code>egg-scripts start --env=prod --title=upload-server</code><br>因为在 <code>Docker</code> 运行 Egg 应用需要是前台模式运行</p></blockquote><pre><code class="dockerfile">FROM node:lts-alpine# 设置时区RUN apk --update add tzdata \    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \    &amp;&amp; apk del tzdataWORKDIR /upload-serverCOPY package*.json ./RUN npm install --registry=https://registry.npm.taobao.orgCOPY . /upload-serverRUN npm run tsc &amp;&amp; npm prune --productionEXPOSE 7001CMD npm start</code></pre><p>有了镜像后，写一个运行容器的脚本，添加可执行的权限，之后启动服务就可以只用运行这个脚本即可。</p><pre><code class="sh">#!/bin/bashset -eIMAGE_NAME=&quot;upload-server&quot;CONTAINER_NAME=&quot;upload-server&quot;echo &#39;拉取代码&#39;git pull origin masterecho &#39;运行容器&#39;docker rm -f ${CONTAINER_NAME} || truedocker build -t ${IMAGE_NAME} .docker run -d -p 7001:7001 --env-file .env --name=${CONTAINER_NAME} ${IMAGE_NAME}exitEOF</code></pre><pre><code class="bash">chmod +x ./deploy.sh</code></pre><p>运行脚本</p><pre><code class="bash">./deploy.sh</code></pre><h2 id="请求频率限制"><a href="#请求频率限制" class="headerlink" title="请求频率限制"></a>请求频率限制</h2><p>为了防止接口被滥用需要限制请求接口的频率，在 Github 找到一个 <a href="https://github.com/koajs/ratelimit" target="_blank" rel="noopener">koa-ratelimit</a> 的仓库，由于 Egg.js 支持 Koa 的插件，所以也适合。</p><p>参考这个仓库的文档，在项目 <code>middleware</code> 文件添加一个 <code>ratelimit.ts</code>，用这个中间件来控制，一开始使用的 <code>redis</code> 作为 <code>driver</code> 可是遇到一个 <code>docker-compose</code> 网络链接问题始终无法解决，遂放弃，改用内存模式。</p><pre><code class="ts">import * as Redis from &#39;ioredis&#39;import * as ratelimit from &#39;koa-ratelimit&#39;const db = new Map();export default () =&gt; {  return ratelimit({    db: db,    driver: &#39;memory&#39;,    duration: 60000,    errorMessage: &#39;请求次数超过限制&#39;,    id: ctx =&gt; ctx.ip,    headers: {      remaining: &#39;Upload-Limit-Remaining&#39;,      reset: &#39;Uplaod-Limit-Reset&#39;,      total: &#39;Upload-Limit-Total&#39;,    },    max: 300,    disableHeader: false,  })}</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><strong><em>上传到 OSS 的图片在浏览器无法预览变为下载</em></strong></p><p>首先阿里云规定</p><blockquote><p>对于图片文件（在未修改文件http头的情况下）：<br>若您的Bucket是2019年9月23日前创建的，使用OSS默认访问域名或自有域名生成的文件URL从浏览器访问时可以预览文件内容。<br>若您的Bucket是2019年9月23日后创建的，使用OSS默认域名生成的文件URL从浏览器访问时会以附件形式下载；使用自有域名生成的文件URL访问时，可以预览&gt; 文件内容。绑定自有域名步骤请参见绑定自定义域名。</p></blockquote><p>然后是上传的图片不能添加 <code>Content-Disposition</code> 返回头信息，给文件添加了这个 http 返回头，也会让图片变成下载。</p><hr><p><strong><em><code>egg-multipart</code> 插件使用 <code>stream</code> 模式无法获取请求体传过来的参数</em></strong></p><p>用 <code>file</code> 模式能够正确的拿到 <code>ctx.request.body</code> 里的请求参数，但是将使用 <code>stream</code> 模式就无法获取，搜索了一下后发现使用 <code>stream</code> 模式需要将上传文件放到表单的最后一项去，不然拿不到其它参数。</p><blockquote><p><a href="https://eggjs.org/zh-cn/basics/controller.html#%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">https://eggjs.org/zh-cn/basics/controller.html#%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6</a><br>只支持上传一个文件。<br>上传文件必须在所有其他的 fields 后面，否则在拿到文件流时可能还获取不到 fields。</p></blockquote><hr><p><strong><em>Redis 无法链接问题</em></strong></p><p>用以下的 <code>docker-compose.yml</code> 文件启动 Egg.js 应用和一个 <code>Redis</code> 服务，然后想在上传接口的请求频率限制的中间件中使用这个 <code>Redis</code> 服务，然后一直报链接失败…Google 之后试了几种方法依然没有成功 :sad:</p><pre><code class="yml">version: &quot;3&quot;services:  redis:    image: redis:alpine    container_name: redis    restart: always    hostname: redis    ports:      - &quot;6379:6379&quot;    networks:       - upload-server-network  upload_server:    build:      context: .      dockerfile: Dockerfile    container_name: upload_server    restart: always    environment:      - EGG_SERVER_ENV:prod    ports:      - 7001:7001    depends_on:      - redis    networks:      - upload-server-networknetworks:  upload-server-network:    driver: bridge</code></pre><hr><p><strong><em>Egg.js 全局错误处理返回格式问题</em></strong></p><p>Egg.js 本身有一个全局错误处理的插件 <a href="https://github.com/eggjs/egg-onerror" target="_blank" rel="noopener">egg-onerror</a>，但是用这个插件在处理上传文件的异常时，直接 <code>throw</code> 错误，返回给前端的数据格式是文本类型的，不是 json 格式，除非前端在发送请求的添加 <code>Accept: application/json</code> 请求头信息。<br>只能在 <code>config.default.js</code> 使用 <code>all</code> 进行捕获异常，然后用 <code>JSON.stringify</code> 方法在处理一遍，这样 <code>throw new Error(e.message)</code> 的时候返回给前端的才是 json。</p><pre><code class="js">config.onerror = {  all(err, ctx) {    ctx.status = err.status || 500    ctx.body = JSON.stringify({      code: ctx.status,      success: false,      message: err.message,    })  },}</code></pre><p>最终还是没有使用这个插件，自己添加了一个方法，进行异常捕获。</p><pre><code class="ts">private error(msg) {  const { ctx } = this  ctx.status = 400  ctx.body = {    code: ctx.status,    success: false,    message: msg,  }}...this.error(&#39;错误的 bucket&#39;)return</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./images/egg.jpg&quot; alt=&quot;egg&quot;&gt;&lt;/p&gt;&lt;p&gt;总结一下之前用 Egg.js 开发的文件上传接口的任务&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Node" scheme="https://coldstone.fun/tags/Node/"/>
    
      <category term="Egg.js" scheme="https://coldstone.fun/tags/Egg-js/"/>
    
  </entry>
  
  <entry>
    <title>使用 Flutter 实现一个走马灯布局</title>
    <link href="https://coldstone.fun/post/2019/11/20/flutter-carousel/"/>
    <id>https://coldstone.fun/post/2019/11/20/flutter-carousel/</id>
    <published>2019-11-20T07:55:26.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<img src="images/carousel.jpg" height="334"><p>走马灯是一种常见的效果，本文讲一下如何用 <code>PageView</code> 在 <code>Flutter</code> 里实现一个走马灯</p><a id="more"></a><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>实现的效果如下，当前页面的高度比其它页面高，切换页面的时候有一个高度变化的动画。实现这样的效果主要用到的是 <code>PageView.builder</code> 部件。</p><div><video src="videos/heroes.mp4" controls width="320" autoplay muted></div><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="创建首页"><a href="#创建首页" class="headerlink" title="创建首页"></a>创建首页</h3><p>首先创建一个 <code>IndexPage</code> 部件，这个部件用来放 <code>PageView</code>，因为需要使用 <code>setState</code> 方法更新 UI，所以它是 stateful 的。</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class IndexPage extends StatefulWidget {  @override  _IndexPageState createState() =&gt; _IndexPageState();}class _IndexPageState extends State&lt;IndexPage&gt; {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        elevation: 0.0,        backgroundColor: Colors.white,      ),      body: Column(        children: &lt;Widget&gt;[],      ),    );  }}</code></pre><p>然后在部件内申明一个 <code>_pageIndex</code> 变量用来保存当前显示的页面的 index，在 <code>initState</code> 生命周期里面初始化一个 <code>PageController</code> 用来配置 <code>PageView</code> 部件。</p><p>在 <code>body</code> 的 <code>Column</code> 里面创建一个 <code>PageView.builder</code>，使用一个 <code>SizedBox</code> 部件指定 <code>PageView</code> 的高度，将 <code>controller</code> 设置为 <code>_pageController</code>，在 <code>onPageChanged</code> 事件里将当前显示页面的 <code>index</code> 值赋值给 <code>_pageIndex</code> 变量。</p><pre><code class="dart">int _pageIndex = 0;PageController _pageController;@overridevoid initState() {  super.initState();  _pageController = PageController(    initialPage: 0,    viewportFraction: 0.8,  );}body: Column(  children: &lt;Widget&gt;[    SizedBox(      height: 580.0,      child: PageView.builder(        itemCount: 3,        pageSnapping: true,        controller: _pageController,        onPageChanged: (int index) {          setState(() {            _pageIndex = index;          });        },        itemBuilder: (BuildContext ctx, int index) {          return _buildItem(_pageIndex, index);        },      ),    ),  ],),</code></pre><blockquote><p>关键点: 设置 <code>PageController</code> 的 <code>viewportFraction</code> 参数小于 1，这个值是用来设置每个页面在屏幕上显示的比例，小于 1 的话，就可以在当前页面同时显示其它页面的内容了。</p><pre><code class="dart">/// The fraction of the viewport that each page should occupy./// Defaults to 1.0, which means each page fills the viewport in the scrolling direction.final double viewportFraction;</code></pre></blockquote><h3 id="实现-buildItem"><a href="#实现-buildItem" class="headerlink" title="实现 _buildItem"></a>实现 <code>_buildItem</code></h3><p>接着实现 <code>_buildItem</code> 方法，这个方法就是返回 <code>PageView.builder</code> 里每一个页面渲染的内容，第一个参数 <code>activeIndex</code> 是当前显示在屏幕上页面的 <code>index</code>，第二个参数 <code>index</code> 是每一项自己的 <code>index</code>。</p><p>使用一个 <code>Center</code> 部件让内容居中显示，然后用一个 <code>AnimatedContainer</code> 添加页面切换时的高度变化的动画效果，切换页面的时候使用了<code>setState</code> 方法改变了 <code>_pageIndex</code>，<code>Flutter</code> 重新绘制每一项。关键点在于判断当前页面是否为正在显示的页面，是的话它的高度就是 500 不是的话就是 450。</p><pre><code class="dart">_buildItem(activeIndex, index) {  return Center(    child: AnimatedContainer(      curve: Curves.easeInOut,      duration: Duration(milliseconds: 300),      height: activeIndex == index ? 500.0 : 450.0,      margin: EdgeInsets.symmetric(vertical: 20.0, horizontal: 10.0),      decoration: BoxDecoration(        color: heroes[index].color,        borderRadius: BorderRadius.all(Radius.circular(12.0)),      ),      child: Stack(),    ),  );}</code></pre><img src="images/empty00.jpg" width="320" style="width:320px"><h3 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h3><p>然后给 <code>AnimatedContainer</code> 添加每一项的内容</p><pre><code class="dart">child: Stack(  fit: StackFit.expand,  children: &lt;Widget&gt;[    ClipRRect(      borderRadius: BorderRadius.all(        Radius.circular(12.0),      ),      child: Image.network(        heroes[index].image,        fit: BoxFit.cover,      ),    ),    Align(      alignment: Alignment.bottomCenter,      child: Row(        children: &lt;Widget&gt;[          Expanded(            child: Container(              padding: EdgeInsets.all(12.0),              decoration: BoxDecoration(                color: Colors.black26,                borderRadius: BorderRadius.only(                  bottomRight: Radius.circular(12.0),                  bottomLeft: Radius.circular(12.0),                ),              ),              child: Text(                heroes[index].title,                textAlign: TextAlign.center,                style: TextStyle(                  fontSize: 20.0,                  fontWeight: FontWeight.bold,                  color: Colors.white,                ),              ),            ),          )        ],      ),    ),  ],),</code></pre><h3 id="实现指示器"><a href="#实现指示器" class="headerlink" title="实现指示器"></a>实现指示器</h3><p>然后实现页面的指示器，创建一个 <code>PageIndicator</code> 部件，需要传入 <code>pageCount</code> 表示总页数，以及 <code>currentIndex</code> 表示当前显示的页数索引。把所有指示器放在一个 <code>Row</code> 部件里，判断当前指示器的 <code>index</code> 是否为正在显示页面的 <code>index</code>，是的话显示较深的颜色。</p><pre><code class="dart">class PageIndicator extends StatelessWidget {  final int pageCount;  final int currentIndex;  const PageIndicator(this.currentIndex, this.pageCount);  Widget _indicator(bool isActive) {    return Container(      width: 6.0,      height: 6.0,      margin: EdgeInsets.symmetric(horizontal: 3.0),      decoration: BoxDecoration(        color: isActive ? Color(0xff666a84) : Color(0xffb9bcca),        shape: BoxShape.circle,        boxShadow: [          BoxShadow(            color: Colors.black12,            offset: Offset(0.0, 3.0),            blurRadius: 3.0,          ),        ],      ),    );  }  List&lt;Widget&gt; _buildIndicators() {    List&lt;Widget&gt; indicators = [];    for (int i = 0; i &lt; pageCount; i++) {      indicators.add(i == currentIndex ? _indicator(true) : _indicator(false));    }    return indicators;  }  @override  Widget build(BuildContext context) {    return Row(      mainAxisAlignment: MainAxisAlignment.center,      children: _buildIndicators(),    );  }}</code></pre><p>添加 <code>PageIndicator</code> 到 <code>SizedBox</code> 下放</p><h3 id="封装-Carousel"><a href="#封装-Carousel" class="headerlink" title="封装 Carousel"></a>封装 <code>Carousel</code></h3><p>最后的最后优化一下代码，把部件封装一下，让它成为一个单独的部件，创建一个 <code>Carousel</code> 部件，对外暴露 <code>items</code> 和 <code>height</code> 两个属性，分别配置数据和高度。</p><pre><code class="dart">class Carousel extends StatefulWidget {  final List items;  final double height;  const Carousel({    @required this.items,    @required this.height,  });  @override  _CarouselState createState() =&gt; _CarouselState();}class _CarouselState extends State&lt;Carousel&gt; {  int _pageIndex = 0;  PageController _pageController;  Widget _buildItem(activeIndex, index) {    final items = widget.items;    return Center(      child: AnimatedContainer(        curve: Curves.easeInOut,        duration: Duration(milliseconds: 300),        height: activeIndex == index ? 500.0 : 450.0,        margin: EdgeInsets.symmetric(vertical: 20.0, horizontal: 10.0),        decoration: BoxDecoration(          color: items[index].color,          borderRadius: BorderRadius.all(Radius.circular(12.0)),        ),        child: Stack(          fit: StackFit.expand,          children: &lt;Widget&gt;[            ClipRRect(              borderRadius: BorderRadius.all(                Radius.circular(12.0),              ),              child: Image.network(                items[index].image,                fit: BoxFit.cover,              ),            ),            Align(              alignment: Alignment.bottomCenter,              child: Row(                children: &lt;Widget&gt;[                  Expanded(                    child: Container(                      padding: EdgeInsets.all(12.0),                      decoration: BoxDecoration(                        color: Colors.black26,                        borderRadius: BorderRadius.only(                          bottomRight: Radius.circular(12.0),                          bottomLeft: Radius.circular(12.0),                        ),                      ),                      child: Text(                        items[index].title,                        textAlign: TextAlign.center,                        style: TextStyle(                          fontSize: 20.0,                          fontWeight: FontWeight.bold,                          color: Colors.white,                        ),                      ),                    ),                  )                ],              ),            ),          ],        ),      ),    );  }  @override  void initState() {    super.initState();    _pageController = PageController(      initialPage: 0,      viewportFraction: 0.8,    );  }  @override  Widget build(BuildContext context) {    return Column(      children: &lt;Widget&gt;[        Container(          height: widget.height,          child: PageView.builder(            pageSnapping: true,            itemCount: heroes.length,            controller: _pageController,            onPageChanged: (int index) {              setState(() {                _pageIndex = index;              });            },            itemBuilder: (BuildContext ctx, int index) {              return _buildItem(_pageIndex, index);            },          ),        ),        PageIndicator(_pageIndex, widget.items.length),      ],    );  }}</code></pre><p>之后在 <code>IndexPage</code> 部件里就只用实例化一个 <code>Carousel</code> 了，同时由于 <code>IndexPage</code> 不用管理部件状态了，可以将它变成 <code>StatelessWidget</code>。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class Hero {  final Color color;  final String image;  final String title;  Hero({    @required this.color,    @required this.image,    @required this.title,  });}List heroes = [  Hero(    color: Color(0xFF86F3FB),    image: &quot;https://game.gtimg.cn/images/lol/act/img/skin/big22009.jpg&quot;,    title: &#39;寒冰射手-艾希&#39;,  ),  Hero(    color: Color(0xFF7D6588),    image: &quot;https://game.gtimg.cn/images/lol/act/img/skin/big39006.jpg&quot;,    title: &#39;刀锋舞者-艾瑞莉娅&#39;,  ),  Hero(    color: Color(0xFF4C314D),    image: &quot;https://game.gtimg.cn/images/lol/act/img/skin/big103015.jpg&quot;,    title: &#39;九尾妖狐-阿狸&#39;,  ),];class Carousel extends StatefulWidget {  final List items;  final double height;  const Carousel({    @required this.items,    @required this.height,  });  @override  _CarouselState createState() =&gt; _CarouselState();}class _CarouselState extends State&lt;Carousel&gt; {  int _pageIndex = 0;  PageController _pageController;  Widget _buildItem(activeIndex, index) {    final items = widget.items;    return Center(      child: AnimatedContainer(        curve: Curves.easeInOut,        duration: Duration(milliseconds: 300),        height: activeIndex == index ? 500.0 : 450.0,        margin: EdgeInsets.symmetric(vertical: 20.0, horizontal: 10.0),        decoration: BoxDecoration(          color: items[index].color,          borderRadius: BorderRadius.all(Radius.circular(12.0)),        ),        child: Stack(          fit: StackFit.expand,          children: &lt;Widget&gt;[            ClipRRect(              borderRadius: BorderRadius.all(                Radius.circular(12.0),              ),              child: Image.network(                items[index].image,                fit: BoxFit.cover,              ),            ),            Align(              alignment: Alignment.bottomCenter,              child: Row(                children: &lt;Widget&gt;[                  Expanded(                    child: Container(                      padding: EdgeInsets.all(12.0),                      decoration: BoxDecoration(                        color: Colors.black26,                        borderRadius: BorderRadius.only(                          bottomRight: Radius.circular(12.0),                          bottomLeft: Radius.circular(12.0),                        ),                      ),                      child: Text(                        items[index].title,                        textAlign: TextAlign.center,                        style: TextStyle(                          fontSize: 20.0,                          fontWeight: FontWeight.bold,                          color: Colors.white,                        ),                      ),                    ),                  )                ],              ),            ),          ],        ),      ),    );  }  @override  void initState() {    super.initState();    _pageController = PageController(      initialPage: 0,      viewportFraction: 0.8,    );  }  @override  Widget build(BuildContext context) {    return Column(      children: &lt;Widget&gt;[        Container(          height: widget.height,          child: PageView.builder(            pageSnapping: true,            itemCount: heroes.length,            controller: _pageController,            onPageChanged: (int index) {              setState(() {                _pageIndex = index;              });            },            itemBuilder: (BuildContext ctx, int index) {              return _buildItem(_pageIndex, index);            },          ),        ),        PageIndicator(_pageIndex, widget.items.length),      ],    );  }}class PageIndicator extends StatelessWidget {  final int currentIndex;  final int pageCount;  const PageIndicator(this.currentIndex, this.pageCount);  Widget _indicator(bool isActive) {    return Container(      width: 6.0,      height: 6.0,      margin: EdgeInsets.symmetric(horizontal: 3.0),      decoration: BoxDecoration(        color: isActive ? Color(0xff666a84) : Color(0xffb9bcca),        shape: BoxShape.circle,        boxShadow: [          BoxShadow(            color: Colors.black12,            offset: Offset(0.0, 3.0),            blurRadius: 3.0,          ),        ],      ),    );  }  List&lt;Widget&gt; _buildIndicators() {    List&lt;Widget&gt; indicators = [];    for (int i = 0; i &lt; pageCount; i++) {      indicators.add(i == currentIndex ? _indicator(true) : _indicator(false));    }    return indicators;  }  @override  Widget build(BuildContext context) {    return Row(      mainAxisAlignment: MainAxisAlignment.center,      children: _buildIndicators(),    );  }}class IndexPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        elevation: 0.0,        backgroundColor: Colors.white,      ),      body: Carousel(        height: 540,        items: heroes,      ),      backgroundColor: Colors.white,    );  }}</code></pre><p>至此，整个布局就完成了！ 😎</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;images/carousel.jpg&quot; height=&quot;334&quot;&gt;&lt;p&gt;走马灯是一种常见的效果，本文讲一下如何用 &lt;code&gt;PageView&lt;/code&gt; 在 &lt;code&gt;Flutter&lt;/code&gt; 里实现一个走马灯&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>分享两道面试题</title>
    <link href="https://coldstone.fun/post/2019/11/15/two-interview-question/"/>
    <id>https://coldstone.fun/post/2019/11/15/two-interview-question/</id>
    <published>2019-11-15T02:33:15.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p>前几天遇到两个前端面试题，要写代码的那种，然后我都没做对…记录一下</p><a id="more"></a><p>前几天遇到两个前端面试题，要写代码的那种，然后我都没做对…记录一下</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>JavaScript 采用原型继承，即一个对象继承自另外一个对象，另外一个对象再继承自别的对象，依此往复。请写一个通用的 JavaScript 函数，来找出某个对象身上的某个属性继承自哪个对象。</p></blockquote><p>解答: 实际上是在考察如何判断一个对象上的属性是本身的还是通过继承来的，使用 <code>hasOwnProperty</code> 和 <code>getPrototypeOf</code> 方法即可</p><pre><code>function getPrototype(obj, key) {  if (obj.hasOwnProperty(key)) {    return obj  }  return getPrototype(Object.getPrototypeOf(obj), key)}const obj = { a: 'a' }const o1 = Object.create(obj)o1.b = 'b'console.log(o1.a) // aconsole.log(o1.b) // bconsole.log(o1.hasOwnProperty('a')) // falseconsole.log(o1.hasOwnProperty('b')) // trueconsole.log(getPrototype(o1, 'a')) // { a: 'a' }console.log(getPrototype(o1, 'b')) // { b: 'b' }</code></pre><p>相关文章</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><blockquote><p><code>URLSearchParams()</code> 可以解析和处理URL参数，目前兼容性一般，请实现 <code>class URLSearchParams</code> 的 polyfill。</p><pre><code class="js">searchParams = new URLSearchParams(&quot;foo=1&amp;bar=2&quot;)// 或者这样传入searchParams = new URLSearchParams({foo: &quot;1&quot;, bar: &quot;2&quot;})// 实例支持 get()、set()、has()、append() 四个方法// 支持以下方式searchParams.get(&quot;foo&quot;) // 1searchParams.set(&quot;foo&quot;, &quot;10&quot;)searchParams.has(&quot;bar&quot;)searchParams.append(&quot;foo&quot;, &quot;100&quot;)</code></pre></blockquote><p>解答：简单实现了下，看了 Github 上 <code>URLSearchParams</code> 的 polyfill 代码，发现这个还是有点复杂的</p><pre><code>class URLSearchParams {  constructor (query) {    this._query = {}    if (typeof query === 'string') {      if (query.startsWith('?', 0)) {        query = query.slice(1)      }      query.split('&').forEach(pair => {        const params = pair.split('=')        const key = params[0]        const val = params[1]        this._query[key] = val      })    } else {      for (let [key, value] of Object.entries(query)) {        this._query[key] = query[key]      }    }  }  get (key) {    return this.has(key) ? this._query[key] : null  }  set (key, val) {    this._query[key] = encodeURIComponent(val)    return true  }  has (key) {    return key in this._query  }  append (key, val) {    const value = Array.isArray(val) ? val.join(',') : val    if (key in this._query) {      this._query[key].push(value)    } else {      this._query[key] = value    }    return this._query[key]  }}const mysp1 = new URLSearchParams('a=aaa&b=bbb')const mysp2 = new URLSearchParams({ c: 'ccc', d: 'ddd' })console.log(mysp1) // URLSearchParams { _query: { a: 'aaa', b: 'bbb' } }console.log(mysp1.get('a')) // aaaconsole.log(mysp1.set('c', 'ccc')) // trueconsole.log(mysp1.has('d')) // falseconsole.log(mysp1.append('e', 'eee')) // eeeconsole.log(mysp1) // { _query: { a: 'aaa', b: 'bbb', c: 'ccc', e: 'eee' } }console.log(mysp2) // URLSearchParams { _query: { c: 'ccc', d: 'ddd' } }console.log(mysp2.get('c')) // cccconsole.log(mysp2.set('d', 'ddd2')) // trueconsole.log(mysp2.has('d')) // trueconsole.log(mysp2.append('f', 'fff')) // fffconsole.log(mysp2) // URLSearchParams { _query: { c: 'ccc', d: 'ddd2', f: 'fff' } }</code></pre><p>相关文章</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">URLSearchParams docs</a></p><p><a href="https://github.com/ungap/url-search-params" target="_blank" rel="noopener">URLSearchParams polyfill</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己太菜了，基础知识由于没有去回顾所以忘的很多，继续加油吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天遇到两个前端面试题，要写代码的那种，然后我都没做对…记录一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Interview" scheme="https://coldstone.fun/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>使用 FFmpeg 转换视频格式</title>
    <link href="https://coldstone.fun/post/2019/11/11/simple-use-ffmpeg/"/>
    <id>https://coldstone.fun/post/2019/11/11/simple-use-ffmpeg/</id>
    <published>2019-11-11T12:12:26.000Z</published>
    <updated>2020-06-18T09:46:58.876Z</updated>
    
    <content type="html"><![CDATA[<p>用 B 站下载助手 下载下来的视频格式是 <code>flv</code>，用 QuickTime 看不了也不能导入 iMovie 进行编辑，所以需要转换一下视频格式。在搜索了很多视频格式转换工具后，发现它们大多底层是用 <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a> 这个开源工具进行转换的，所以为什么不直接用 <code>FFmpeg</code> 它本身呢</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用 B 站下载助手 下载下来的视频格式是 <code>flv</code>，用 QuickTime 看不了也不能导入 iMovie 进行编辑，所以需要转换一下视频格式。在搜索了很多视频格式转换工具后，发现它们大多底层是用 <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a> 这个开源工具进行转换的，所以为什么不直接用 <code>FFmpeg</code> 它本身呢。</p><h2 id="关于-FFmpeg"><a href="#关于-FFmpeg" class="headerlink" title="关于 FFmpeg"></a>关于 FFmpeg</h2><p>官方描述：FFmpeg 是一种非常快速的视频和音频转换器，也可以从实时音频/视频源中获取。 它还可以在任意采样率之间转换，并使用高质量的多相滤波器即时调整视频大小。</p><p>转换流程</p><pre><code class="pre"> _______              ______________|       |            |              || input |  demuxer   | encoded data |   decoder| file  | ---------&gt; | packets      | -----+|_______|            |______________|      |                                           v                                       _________                                      |         |                                      | decoded |                                      | frames  |                                      |_________| ________             ______________       ||        |           |              |      || output | &lt;-------- | encoded data | &lt;----+| file   |   muxer   | packets      |   encoder|________|           |______________|</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先安装 <code>FFmpeg</code>，macOS 可以使用 <code>homebrew</code> 安装</p><pre><code class="sh">brew install ffmpeg</code></pre><p>Windows 到 <code>https://ffmpeg.zeranoe.com/builds</code> 这里下载 zip 包，然后将 <code>bin</code> 目录添加到环境变量 <code>PATH</code> 中，在命令行中运行 <code>ffmpeg</code> 命令，出现提示语即表示安装成功</p><p><img src="images/ffmpeg-hint.jpg" alt="hint"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>只需一条命令即可对视频进行格式转换，<code>-i</code> 参数表示需要转换的视频，值是视频路径，后面的是转换后的视频文件名。</p><pre><code class="sh">ffmpeg -i input.mp4 output.avi</code></pre><p>转换过程中会出现进度提示</p><p><img src="images/ffmpeg-running.jpg" alt="running"></p><ul><li><code>frame</code> 表示是转码所进行到的帧数。</li><li><code>fps</code> 表示中的 FPS 就是 Frame per Second ，是现在电脑每秒所处理的帧的数量，这个数字跟视频的帧率无关。</li><li><code>size</code> 表示已经转换出来的视频的体积。</li><li><code>time</code> 表示经转换出来的视频的时间。</li></ul><h2 id="转换参数"><a href="#转换参数" class="headerlink" title="转换参数"></a>转换参数</h2><p><code>-r</code></p><p>这个选项设置视频帧率, 单位是 Hz，也就是帧每秒 FPS，如 <code>-r 30</code> 即代表输出视频的帧率为每秒 30 帧，降低帧率可以减小视频的体积。</p><pre><code class="sh">ffmpeg -i input.mp4 -r 30 output.mp4</code></pre><p><code>-s</code></p><p>默认输出的视频尺寸与原视频相同，<code>-s 720x480</code> 选项可以指定输出视频的尺寸，以像素为单位。</p><pre><code class="sh">ffmpeg -i input.mp4 -s 720x480 output.mp4</code></pre><p><code>-t</code></p><p>用来指定输出文件的持续时间，以秒为单位，如截取 input.mp4 的前 30 秒并保存为 output.mp4。</p><pre><code class="sh">ffmpeg -i input.mp4 -t 30 output.mp4</code></pre><p><code>-c</code></p><p>用来指定输出文件的编码，设置 <code>-c copy</code> 让 <code>FFmpeg</code> 在转换音视频时不重新进行编码，减少转换耗时。</p><pre><code class="sh">ffmpeg -i input.mp4 -c copy -t 30 output.mp4</code></pre><p>执行 help 命令，可以看到更多关于视频转换的选项</p><pre><code class="sh">ffmpeg -help</code></pre><p><img src="images/ffmpeg-video-opt.jpg" alt="video-options"></p><ul><li><code>-vframes</code> 设置要输出的视频帧数</li><li><code>-r</code> 速率设置帧速率（Hz值，分数或缩写）</li><li><code>-s</code> size设置帧大小（WxH或缩写）</li><li><code>-aspect</code> 宽高比设置的宽高比（4：3、16：9或1.3333、1.7777）</li><li><code>-bits_per_raw_sample</code> 设置每个原始样本的位数</li><li><code>-vn</code> 禁用视频</li><li><code>-vcodec</code> 编解码器强制视频编解码器（“复制”以复制流）</li><li><code>-timecode</code> 单位 hh：mm：ss [：;。] ff设置初始 TimeCode 值。</li><li><code>-pass n</code> 选择通过次数（1到3）</li><li><code>-vf filter_graph</code> 设置视频过滤器</li><li><code>-ab</code> 比特率音频比特率（请使用-b：a）</li><li><code>-b</code> 比特率视频比特率（请使用-b：v）</li><li><code>-dn</code> 禁用数据</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ffmpeg.org/documentation.html" target="_blank" rel="noopener">FFmpeg Documentation</a></p><p><a href="https://wiki.fiveyellowmice.com/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8_FFmpeg_%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81:%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">如何使用_FFmpeg_进行视频转码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 B 站下载助手 下载下来的视频格式是 &lt;code&gt;flv&lt;/code&gt;，用 QuickTime 看不了也不能导入 iMovie 进行编辑，所以需要转换一下视频格式。在搜索了很多视频格式转换工具后，发现它们大多底层是用 &lt;a href=&quot;https://www.ffmpeg.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FFmpeg&lt;/a&gt; 这个开源工具进行转换的，所以为什么不直接用 &lt;code&gt;FFmpeg&lt;/code&gt; 它本身呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="FFmpeg" scheme="https://coldstone.fun/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
